{
    "docs": [
        {
            "location": "/index.html",
            "text": "Welcome to MAAS's new command-line tool & Python client library\n\n\n\npython-libmaas\n provides:\n\n\n\n\n\n\nA rich and stable Python client library for interacting with MAAS 2.0+\n  servers. This can be used in a synchronous/blocking mode, or an\n  asynchronous/non-blocking mode based on \nasyncio\n.\n\n\n\n\n\n\nA lower-level Python client library, auto-generated to match the MAAS\n  server it\u2019s interacting with.\n\n\n\n\n\n\nA command-line tool for working with MAAS servers.\n\n\n\n\n\n\nFor MAAS \nserver\n documentation, visit\n\ndocs.ubuntu.com\n.\n\n\n\n\nThis is \nALPHA\n software. We are converging on a finished product, but\nuntil we release a beta all APIs could change.\n\n\n\n\nInstallation\n\n\nEither work from a branch:\n\n\n$ git clone https://github.com/maas/python-libmaas.git\n$ cd python-libmaas\n$ make\n\n\n\n\nOr install with \npip\n into a\n\nvirtualenv\n:\n\n\n$ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install git+https://github.com/maas/python-libmaas.git\n\n\n\n\nOr install from \nPyPI\n:\n\n\n$ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install python-libmaas\n\n\n\n\nNote\n that PyPI may lag the others.\n\n\nThis documentation assumes you\u2019re working from a branch or in a\nvirtualenv. In practice this means it will use partially qualified paths\nlike \nbin/maas\n instead of bare \nmaas\n invocations. If you\u2019ve\ninstalled from PyPI the \nmaas\n command will probably be installed on\nyour shell\u2019s \nPATH\n so you can invoke it as \nmaas\n.\n\n\nCommand-line\n\n\n$ bin/maas profiles login --help\n$ bin/maas profiles login exmpl \\\n>   http://example.com:5240/MAAS/ my_username\nPassword: \u2026\n$ bin/maas list\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u2502 Hostname   \u2502 System ID \u2502 #CPUs \u2502 RAM    \u2502 Status \u2502 Power   \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 m \u2502 botswana   \u2502 pncys4    \u2502 4     \u2502 8.0 GB \u2502 Ready  \u2502 Off     \u2502\n\u2502 c \u2502 namibia    \u2502 xfaxgw    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Error   \u2502\n\u2502 C \u2502 madagascar \u2502 4y3h7n    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Unknown \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n\n\nTab-completion in \nbash\n and \ntcsh\n is supported too. For example,\nin \nbash\n:\n\n\n$ source <(bin/register-python-argcomplete --shell=bash bin/maas)\n$ bin/maas <tab>\nallocate  launch  list  list-files  list-tags  ...\n\n\n\n\nClient library\n\n\nFor a developer the simplest entry points into \npython-libmaas\n are\nthe \nconnect\n and \nlogin\n functions in \nmaas.client\n. The former\nconnects to a MAAS server using a previously obtained API key, and the\nlatter logs-in to MAAS with your username and password. These returns a\n\nClient\n object that has convenient attributes for working with MAAS.\n\n\nFor example, this prints out all interfaces on all machines:\n\n\nfrom maas.client import login\nclient = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"my_user\", password=\"my_pass\",\n)\ntmpl = \"{0.hostname} {1.name} {1.mac_address}\"\nfor machine in client.machines.list():\n    for interface in machine.interfaces:\n        print(tmpl.format(machine, interface))\n\n\n\n\nLearn more about the \nclient\n.\n\n\nShell\n\n\nThere\u2019s an interactive shell. If a profile name is given or a default\nprofile has been set \u2014 see \nmaas profiles --help\n \u2014 this places a\n\nClient\n instance in the default namespace (as \nclient\n) that you\ncan use interactively or in a script.\n\n\nFor the best experience install \nIPython\n first.\n\n\n$ bin/maas shell\nWelcome to the MAAS shell.\n...\n\n\n\n\n>>> origin.Version.read()\n<Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]>\n>>> dir(client)\n[..., 'account', 'boot_resources', ...]\n\n\n\n\nScripts can also be run. For example, given the following \nscript.py\n:\n\n\nprint(\"Machines:\", len(client.machines.list()))\nprint(\"Devices:\", len(client.devices.list()))\nprint(\"Racks:\", len(client.rack_controllers.list()))\nprint(\"Regions:\", len(client.region_controllers.list()))\n\n\n\n\nthe following will run it against the default profile:\n\n\n$ bin/maas shell script.py\nMachines: 1\nDevices: 0\nRacks: 2\nRegions: 1\n\n\n\n\nDevelopment\n\n\nIt\u2019s easy to start hacking on \npython-libmaas\n:\n\n\n$ git clone git@github.com:maas/python-libmaas.git\n$ cd python-libmaas\n$ make develop\n$ make test\n\n\n\n\nInstalling \nIPython\n is generally a good idea too:\n\n\n$ bin/pip install -UI IPython\n\n\n\n\nPull requests are welcome but authors need to sign the \nCanonical\ncontributor license agreement\n before those PRs can be merged.\n\n\nbones\n & \nviscera\n\n\nDigging around in the code and when using the primary client API, you\nmay find references to \nbones\n and \nviscera\n. These libraries form the\nbase for the client API:\n\n\n\n\n\n\nbones\n is a lower-level library that closely\n  mirrors MAAS\u2019s Web API. Every MAAS server publishes a description of\n  its Web API and \nbones\n generates a convenient mechanism to interact\n  with it.\n\n\n\n\n\n\nviscera\n is a higher-level library which makes\n  heavy use of \nbones\n. MAAS\u2019s Web API is sometimes unfriendly or\n  inconsistent, but \nviscera\n presents a hand-crafted API that has been\n  designed for developers rather than machines.",
            "title": "Home"
        },
        {
            "location": "/index.html#installation",
            "text": "Either work from a branch:  $ git clone https://github.com/maas/python-libmaas.git\n$ cd python-libmaas\n$ make  Or install with  pip  into a virtualenv :  $ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install git+https://github.com/maas/python-libmaas.git  Or install from  PyPI :  $ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install python-libmaas  Note  that PyPI may lag the others.  This documentation assumes you\u2019re working from a branch or in a\nvirtualenv. In practice this means it will use partially qualified paths\nlike  bin/maas  instead of bare  maas  invocations. If you\u2019ve\ninstalled from PyPI the  maas  command will probably be installed on\nyour shell\u2019s  PATH  so you can invoke it as  maas .",
            "title": "Installation"
        },
        {
            "location": "/index.html#command-line",
            "text": "$ bin/maas profiles login --help\n$ bin/maas profiles login exmpl \\\n>   http://example.com:5240/MAAS/ my_username\nPassword: \u2026\n$ bin/maas list\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u2502 Hostname   \u2502 System ID \u2502 #CPUs \u2502 RAM    \u2502 Status \u2502 Power   \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 m \u2502 botswana   \u2502 pncys4    \u2502 4     \u2502 8.0 GB \u2502 Ready  \u2502 Off     \u2502\n\u2502 c \u2502 namibia    \u2502 xfaxgw    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Error   \u2502\n\u2502 C \u2502 madagascar \u2502 4y3h7n    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Unknown \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  Tab-completion in  bash  and  tcsh  is supported too. For example,\nin  bash :  $ source <(bin/register-python-argcomplete --shell=bash bin/maas)\n$ bin/maas <tab>\nallocate  launch  list  list-files  list-tags  ...",
            "title": "Command-line"
        },
        {
            "location": "/index.html#client-library",
            "text": "For a developer the simplest entry points into  python-libmaas  are\nthe  connect  and  login  functions in  maas.client . The former\nconnects to a MAAS server using a previously obtained API key, and the\nlatter logs-in to MAAS with your username and password. These returns a Client  object that has convenient attributes for working with MAAS.  For example, this prints out all interfaces on all machines:  from maas.client import login\nclient = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"my_user\", password=\"my_pass\",\n)\ntmpl = \"{0.hostname} {1.name} {1.mac_address}\"\nfor machine in client.machines.list():\n    for interface in machine.interfaces:\n        print(tmpl.format(machine, interface))  Learn more about the  client .",
            "title": "Client library"
        },
        {
            "location": "/index.html#shell",
            "text": "There\u2019s an interactive shell. If a profile name is given or a default\nprofile has been set \u2014 see  maas profiles --help  \u2014 this places a Client  instance in the default namespace (as  client ) that you\ncan use interactively or in a script.  For the best experience install  IPython  first.  $ bin/maas shell\nWelcome to the MAAS shell.\n...  >>> origin.Version.read()\n<Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]>\n>>> dir(client)\n[..., 'account', 'boot_resources', ...]  Scripts can also be run. For example, given the following  script.py :  print(\"Machines:\", len(client.machines.list()))\nprint(\"Devices:\", len(client.devices.list()))\nprint(\"Racks:\", len(client.rack_controllers.list()))\nprint(\"Regions:\", len(client.region_controllers.list()))  the following will run it against the default profile:  $ bin/maas shell script.py\nMachines: 1\nDevices: 0\nRacks: 2\nRegions: 1",
            "title": "Shell"
        },
        {
            "location": "/index.html#development",
            "text": "It\u2019s easy to start hacking on  python-libmaas :  $ git clone git@github.com:maas/python-libmaas.git\n$ cd python-libmaas\n$ make develop\n$ make test  Installing  IPython  is generally a good idea too:  $ bin/pip install -UI IPython  Pull requests are welcome but authors need to sign the  Canonical\ncontributor license agreement  before those PRs can be merged.",
            "title": "Development"
        },
        {
            "location": "/index.html#bones-viscera",
            "text": "Digging around in the code and when using the primary client API, you\nmay find references to  bones  and  viscera . These libraries form the\nbase for the client API:    bones  is a lower-level library that closely\n  mirrors MAAS\u2019s Web API. Every MAAS server publishes a description of\n  its Web API and  bones  generates a convenient mechanism to interact\n  with it.    viscera  is a higher-level library which makes\n  heavy use of  bones . MAAS\u2019s Web API is sometimes unfriendly or\n  inconsistent, but  viscera  presents a hand-crafted API that has been\n  designed for developers rather than machines.",
            "title": "bones &amp; viscera"
        },
        {
            "location": "/client/index.html",
            "text": "The Web API client\n\n\n\nCalling \nmaas.client.connect\n or \nmaas.client.login\n (MAAS 2.2+\nonly) will return a \nmaas.client.facade.Client\n instance. This\nprovides an easy to understand starting point for working with MAAS\u2019s\nWeb API.\n\n\nAn example\n\n\n#!/usr/bin/env python3.5\n\nfrom maas.client import connect\n\n# Replace \u2026 with an API key previously obtained by hand from\n# http://$host:$port/MAAS/account/prefs/.\nclient = maas.client.connect(\n    \"http://localhost:5240/MAAS/\", apikey=\"\u2026\")\n\n# Get a reference to self.\nmyself = client.users.whoami()\nassert myself.is_admin, \"%s is not an admin\" % myself.username\n\n# Check for a MAAS server capability.\nversion = client.version.get()\nassert \"devices-management\" in version.capabilities\n\n# Check the default OS and distro series for deployments.\nprint(client.maas.get_default_os())\nprint(client.maas.get_default_distro_series())\n\n# Set the HTTP proxy.\nclient.maas.set_http_proxy(\"http://localhost:3128\")\n\n# Allocate and deploy a machine.\nmachine = client.machines.allocate()\nmachine.deploy()\n\n\n\n\nUsing \nlogin\n\n\nAlternatively, a client can be obtained from a username and password,\nreplacing the call to \nconnect\n above. This only works in MAAS 2.2 and\nabove; below that a \nLoginNotSupported\n exception will be raised.\n\n\nclient = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"foo\", password=\"bar\",\n)\n\n\n\n\nAgain, but asynchronous\n\n\nAt first glance \npython-libmaas\n appears to be a blocking API, but it\u2019s\nactually asynchronous under the skin, based on \nasyncio\n. If you call\ninto \npython-libmaas\n from within a running event loop it will behave\nasynchronously, but called from outside it behaves synchronously, and\nblocks.\n\n\nUsing \npython-libmaas\n interactively, when exploring the library or\ntrying something out, is familiar and natural because it behaves as a\nsynchronous, blocking API. This mode can be used of in scripts too, but\nthe same code can be easily repurposed for use in an asynchronous,\nnon-blocking application.\n\n\nBelow shows the earlier example but implemented in an asynchronous\nstyle. Note the use of the \nasynchronous\n decorator: this is used\nheavily in \npython-libmaas\n \u2014 along with the \nAsynchronous\n metaclass\n\u2014 to create the automatic blocking/not-blocking behaviour.\n\n\n#!/usr/bin/env python3.5\n\nfrom maas.client import login\nfrom maas.client.utils.async import asynchronous\n\n@asynchronous\nasync def work_with_maas():\n    client = await login(\n        \"http://eucula.local:5240/MAAS/\",\n        username=\"gavin\", password=\"f00b4r\")\n\n    # Get a reference to self.\n    myself = await client.users.whoami()\n    assert myself.is_admin, \"%s is not an admin\" % myself.username\n\n    # Check for a MAAS server capability.\n    version = await client.version.get()\n    assert \"devices-management\" in version.capabilities\n\n    # Check the default OS and distro series for deployments.\n    print(await client.maas.get_default_os())\n    print(await client.maas.get_default_distro_series())\n\n    # Set the HTTP proxy.\n    await client.maas.set_http_proxy(\"http://localhost:3128\")\n\n    # Allocate and deploy a machine.\n    machine = await client.machines.allocate()\n    await machine.deploy()\n\nwork_with_maas()",
            "title": "Introduction"
        },
        {
            "location": "/client/index.html#an-example",
            "text": "#!/usr/bin/env python3.5\n\nfrom maas.client import connect\n\n# Replace \u2026 with an API key previously obtained by hand from\n# http://$host:$port/MAAS/account/prefs/.\nclient = maas.client.connect(\n    \"http://localhost:5240/MAAS/\", apikey=\"\u2026\")\n\n# Get a reference to self.\nmyself = client.users.whoami()\nassert myself.is_admin, \"%s is not an admin\" % myself.username\n\n# Check for a MAAS server capability.\nversion = client.version.get()\nassert \"devices-management\" in version.capabilities\n\n# Check the default OS and distro series for deployments.\nprint(client.maas.get_default_os())\nprint(client.maas.get_default_distro_series())\n\n# Set the HTTP proxy.\nclient.maas.set_http_proxy(\"http://localhost:3128\")\n\n# Allocate and deploy a machine.\nmachine = client.machines.allocate()\nmachine.deploy()",
            "title": "An example"
        },
        {
            "location": "/client/index.html#using-login",
            "text": "Alternatively, a client can be obtained from a username and password,\nreplacing the call to  connect  above. This only works in MAAS 2.2 and\nabove; below that a  LoginNotSupported  exception will be raised.  client = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"foo\", password=\"bar\",\n)",
            "title": "Using login"
        },
        {
            "location": "/client/index.html#again-but-asynchronous",
            "text": "At first glance  python-libmaas  appears to be a blocking API, but it\u2019s\nactually asynchronous under the skin, based on  asyncio . If you call\ninto  python-libmaas  from within a running event loop it will behave\nasynchronously, but called from outside it behaves synchronously, and\nblocks.  Using  python-libmaas  interactively, when exploring the library or\ntrying something out, is familiar and natural because it behaves as a\nsynchronous, blocking API. This mode can be used of in scripts too, but\nthe same code can be easily repurposed for use in an asynchronous,\nnon-blocking application.  Below shows the earlier example but implemented in an asynchronous\nstyle. Note the use of the  asynchronous  decorator: this is used\nheavily in  python-libmaas  \u2014 along with the  Asynchronous  metaclass\n\u2014 to create the automatic blocking/not-blocking behaviour.  #!/usr/bin/env python3.5\n\nfrom maas.client import login\nfrom maas.client.utils.async import asynchronous\n\n@asynchronous\nasync def work_with_maas():\n    client = await login(\n        \"http://eucula.local:5240/MAAS/\",\n        username=\"gavin\", password=\"f00b4r\")\n\n    # Get a reference to self.\n    myself = await client.users.whoami()\n    assert myself.is_admin, \"%s is not an admin\" % myself.username\n\n    # Check for a MAAS server capability.\n    version = await client.version.get()\n    assert \"devices-management\" in version.capabilities\n\n    # Check the default OS and distro series for deployments.\n    print(await client.maas.get_default_os())\n    print(await client.maas.get_default_distro_series())\n\n    # Set the HTTP proxy.\n    await client.maas.set_http_proxy(\"http://localhost:3128\")\n\n    # Allocate and deploy a machine.\n    machine = await client.machines.allocate()\n    await machine.deploy()\n\nwork_with_maas()",
            "title": "Again, but asynchronous"
        },
        {
            "location": "/client/nodes/index.html",
            "text": "Machines, devices, racks, and regions\n\n\n\nGiven a \nClient\n instance bound to your MAAS server, you can\ninterrogate your nodes.\n\n\nRead nodes\n\n\nEach node type exists on the client: \nmachines\n, \ndevices\n,\n\nrack_controllers\n, \nregion_controllers\n.\n\n\n>>> client.machines.list()\n<Machines length=1 items=[<Machine hostname='wanted-falcon' system_id='ekgqwd'>]>\n>>> client.devices.list()\n<Devices length=0 items=[]>\n>>> client.rack_controllers.list()\n<RackControllers length=1 items=[<RackController hostname='maas-ctrl' system_id='efw3c4'>]>\n>>> client.region_controllers.list()\n<RegionControllers length=1 items=[<RegionController hostname='maas-ctrl' system_id='efw3c4'>]>\n\n\n\n\nEasily iterate through the machines.\n\n\n>>> for machine in client.machines.list():\n...     print(repr(machine))\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nGet a machine from its system_id.\n\n\n>>> machine = client.machines.get(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nMachines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:\n\n\n>>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4\n\n\n\n\nDon\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or\n\ndir(machine)\n to find out what other fields and methods are\navailable.\n\n\nCreate nodes\n\n\nCreate a machine in MAAS. The architecture, MAC addresses, and power type are\nrequired fields.\n\n\n>>> machine = client.machines.create(\n...     \"amd64\", [\"00:11:22:33:44:55\", \"AA:BB:CC:DD:EE:FF\"], \"manual\")\n<Machine hostname='wanted-falcon' system_id='ekgqwd'>\n\n\n\n\nNormally you need to pass in power parameter so MAAS can talk to the BMC.\n\n\n>>> machine = client.machines.create(\n...     \"amd64\", [\"00:11:22:33:44:55\", \"AA:BB:CC:DD:EE:FF\"], \"ipmi\", {\n...         \"power_address\": \"10.245.0.10\",\n...         \"power_user\": \"root\",\n...         \"power_pass\": \"calvin\",\n...     })\n>>> machine\n<Machine hostname='wanted-falcon' system_id='ekgqwd'>\n>>> machine.status\n<NodeStatus.COMMISSIONING: 1>\n\n\n\n\nUpdating nodes\n\n\nUpdating a machine is as simple as modifying the attribute and saving.\n\n\n>>> machine.hostname = 'my-machine'\n>>> machine.architecture = 'i386/generic'\n>>> machine.save()\n\n\n\n\nDeleting nodes\n\n\nDelete a machine is simple as calling delete on the machine object.\n\n\n>>> machine.delete()\n\n\n\n\nCommissioning and testing\n\n\nEasily commission a machine and wait until it successfully completes. By\ndefault the \ncommission\n method waits until commissioning succeeds.\n\n\n>>> machine.commission()\n>>> machine.status\nNodeStatus.READY\n\n\n\n\nA more advanced asyncio based script that runs commissioning with extra scripts\nand waits until all machines have successfully commissioned.\n\n\n#!/usr/bin/env python3.5\n\nimport asyncio\n\nfrom maas.client import login\nfrom maas.client.enum import NodeStatus\nfrom maas.client.utils.async import asynchronous\n\n\n@asynchronous\nasync def commission_all_machines():\n    client = await login(\n        \"http://eucula.local:5240/MAAS/\",\n        username=\"gavin\", password=\"f00b4r\")\n\n    # Get all machines that are in the NEW status.\n    all_machines = await client.machines.list()\n    new_machines = [\n        machine\n        for machine in all_machines\n        if machine.status == NodeStatus.NEW\n    ]\n\n    # Run commissioning with a custom commissioning script on all new machines.\n    for machine in new_machines:\n        machine.commission(\n            commissioning_scripts=['clear_hardware_raid'], wait=False)\n\n    # Wait until all machines are ready.\n    failed_machines = []\n    completed_machines = []\n    while len(new_machines) > 0:\n        await asyncio.sleep(5)\n        for machine in list(new_machines):\n            await machine.refresh()\n            if machine.status in [\n                    NodeStatus.COMMISSIONING, NodeStatus.TESTING]:\n                # Machine is still commissioning or testing.\n                continue\n            elif machine.status == NodeStatus.READY:\n                # Machine is complete.\n                completed_machines.append(machine)\n                new_machines.remove(machine)\n            else:\n                # Machine has failed commissioning.\n                failed_machines.append(machine)\n                new_machines.remove(machine)\n\n    # Print message if any machines failed to commission.\n    if len(failed_machines) > 0:\n        for machine in failed_machines:\n            print(\"%s: transitioned to unexpected status - %s\" % (\n                machine.hostname, machine.status_name))\n    else:\n        print(\"Successfully commissioned %d machines.\" % len(\n            completed_machines))\n\n\ncommission_all_machines()\n\n\n\n\nAllocating and deploying\n\n\n>>> help(client.machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    Allocate a machine.\n\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = client.machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status)\nNodeStatus.COMMISSIONING\n>>> machine.deploy()\n>>> print(machine.status)\nNodeStatus.DEPLOYING",
            "title": "Nodes"
        },
        {
            "location": "/client/nodes/index.html#read-nodes",
            "text": "Each node type exists on the client:  machines ,  devices , rack_controllers ,  region_controllers .  >>> client.machines.list()\n<Machines length=1 items=[<Machine hostname='wanted-falcon' system_id='ekgqwd'>]>\n>>> client.devices.list()\n<Devices length=0 items=[]>\n>>> client.rack_controllers.list()\n<RackControllers length=1 items=[<RackController hostname='maas-ctrl' system_id='efw3c4'>]>\n>>> client.region_controllers.list()\n<RegionControllers length=1 items=[<RegionController hostname='maas-ctrl' system_id='efw3c4'>]>  Easily iterate through the machines.  >>> for machine in client.machines.list():\n...     print(repr(machine))\n<Machine hostname='botswana' system_id='pncys4'>  Get a machine from its system_id.  >>> machine = client.machines.get(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>  Machines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:  >>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4  Don\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or dir(machine)  to find out what other fields and methods are\navailable.",
            "title": "Read nodes"
        },
        {
            "location": "/client/nodes/index.html#create-nodes",
            "text": "Create a machine in MAAS. The architecture, MAC addresses, and power type are\nrequired fields.  >>> machine = client.machines.create(\n...     \"amd64\", [\"00:11:22:33:44:55\", \"AA:BB:CC:DD:EE:FF\"], \"manual\")\n<Machine hostname='wanted-falcon' system_id='ekgqwd'>  Normally you need to pass in power parameter so MAAS can talk to the BMC.  >>> machine = client.machines.create(\n...     \"amd64\", [\"00:11:22:33:44:55\", \"AA:BB:CC:DD:EE:FF\"], \"ipmi\", {\n...         \"power_address\": \"10.245.0.10\",\n...         \"power_user\": \"root\",\n...         \"power_pass\": \"calvin\",\n...     })\n>>> machine\n<Machine hostname='wanted-falcon' system_id='ekgqwd'>\n>>> machine.status\n<NodeStatus.COMMISSIONING: 1>",
            "title": "Create nodes"
        },
        {
            "location": "/client/nodes/index.html#updating-nodes",
            "text": "Updating a machine is as simple as modifying the attribute and saving.  >>> machine.hostname = 'my-machine'\n>>> machine.architecture = 'i386/generic'\n>>> machine.save()",
            "title": "Updating nodes"
        },
        {
            "location": "/client/nodes/index.html#deleting-nodes",
            "text": "Delete a machine is simple as calling delete on the machine object.  >>> machine.delete()",
            "title": "Deleting nodes"
        },
        {
            "location": "/client/nodes/index.html#commissioning-and-testing",
            "text": "Easily commission a machine and wait until it successfully completes. By\ndefault the  commission  method waits until commissioning succeeds.  >>> machine.commission()\n>>> machine.status\nNodeStatus.READY  A more advanced asyncio based script that runs commissioning with extra scripts\nand waits until all machines have successfully commissioned.  #!/usr/bin/env python3.5\n\nimport asyncio\n\nfrom maas.client import login\nfrom maas.client.enum import NodeStatus\nfrom maas.client.utils.async import asynchronous\n\n\n@asynchronous\nasync def commission_all_machines():\n    client = await login(\n        \"http://eucula.local:5240/MAAS/\",\n        username=\"gavin\", password=\"f00b4r\")\n\n    # Get all machines that are in the NEW status.\n    all_machines = await client.machines.list()\n    new_machines = [\n        machine\n        for machine in all_machines\n        if machine.status == NodeStatus.NEW\n    ]\n\n    # Run commissioning with a custom commissioning script on all new machines.\n    for machine in new_machines:\n        machine.commission(\n            commissioning_scripts=['clear_hardware_raid'], wait=False)\n\n    # Wait until all machines are ready.\n    failed_machines = []\n    completed_machines = []\n    while len(new_machines) > 0:\n        await asyncio.sleep(5)\n        for machine in list(new_machines):\n            await machine.refresh()\n            if machine.status in [\n                    NodeStatus.COMMISSIONING, NodeStatus.TESTING]:\n                # Machine is still commissioning or testing.\n                continue\n            elif machine.status == NodeStatus.READY:\n                # Machine is complete.\n                completed_machines.append(machine)\n                new_machines.remove(machine)\n            else:\n                # Machine has failed commissioning.\n                failed_machines.append(machine)\n                new_machines.remove(machine)\n\n    # Print message if any machines failed to commission.\n    if len(failed_machines) > 0:\n        for machine in failed_machines:\n            print(\"%s: transitioned to unexpected status - %s\" % (\n                machine.hostname, machine.status_name))\n    else:\n        print(\"Successfully commissioned %d machines.\" % len(\n            completed_machines))\n\n\ncommission_all_machines()",
            "title": "Commissioning and testing"
        },
        {
            "location": "/client/nodes/index.html#allocating-and-deploying",
            "text": ">>> help(client.machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    Allocate a machine.\n\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = client.machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status)\nNodeStatus.COMMISSIONING\n>>> machine.deploy()\n>>> print(machine.status)\nNodeStatus.DEPLOYING",
            "title": "Allocating and deploying"
        },
        {
            "location": "/client/networking/index.html",
            "text": "Fabrics, VLANs, Subnets, Spaces, IP Ranges, Static Routes\n\n\n\nGiven a \nClient\n instance bound to your MAAS server, you can\ninterrogate your entire networking configuration.\n\n\nRead networking\n\n\nfabrics\n, \nsubnets\n, \nspaces\n, \nip_ranges\n, and \nstatic_routes\n is\nexposed directly on your \nClient\n instance. \nvlans\n are nested under each\n\nFabric\n.\n\n\n>>> fabrics = client.fabrics.list()\n>>> len(fabrics)\n1\n>>> default_fabric = fabrics.get_default()\n>>> default_fabric.name\n'fabric-0'\n>>> default_fabric.vlans\n<Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]>\n>>> for vlan in default_fabric.vlans:\n...     print(vlan)\n...\n<Vlan name='untagged' vid=0>\n>>>\n\n\n\n\nGet a specific subnet and view the \nVlan\n and \nFabric\n that it is\nassigned to. Going up the tree from \nVlan\n to \nFabric\n results in an\nunloaded \nFabric\n. Calling \nrefresh\n on \nFabric\n will load the object\nfrom MAAS.\n\n\n>>> vm_subnet = client.subnets.get('192.168.122.0/24')\n>>> vm_subnet.cidr\n'192.168.122.0/24'\n>>> vm_subnet.vlan\n<Vlan name='untagged' vid=0>\n>>> fabric = vm_subnet.vlan.fabric\n>>> fabric\n<Fabric id=20 (unloaded)>\n>>> fabric.refresh()\n>>> fabric.vlans\nTraceback (most recent call last):\n...\nObjectNotLoaded: cannot access attribute 'vlans' of object 'Fabric'\n>>> fabric.is_loaded\nFalse\n>>> fabric.refresh()\n>>> fabric.is_loaded\nTrue\n>>> fabric.vlans\n<Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]>\n\n\n\n\nAccess to \nspaces\n, \nip_ranges\n, and \nstatic_routes\n works similarly.\n\n\n>>> client.spaces.list()\n>>> client.ip_ranges.list()\n>>> client.static_routes.list()\n\n\n\n\nCreate fabric & vlan\n\n\nCreating a new fabric and vlan is done directly from each set of objects on\nthe \nClient\n respectively.\n\n\n>>> new_fabric = client.fabrics.create()\n>>> new_fabric.name\n'fabric-2'\n>>> new_vlan = new_fabric.vlans.create(20)\n>>> new_vlan\n<Vlan name='' vid=20>\n>>> new_vlan.fabric\n<Fabric id=2 (unloaded)>\n\n\n\n\nCreate subnet\n\n\nCreate a new subnet and assign it to an existing vlan.\n\n\n>>> new_subnet = client.subnets.create('192.168.128.0/24', new_vlan)\n>>> new_subnet.cidr\n'192.168.128.0/24'\n>>> new_subnet.vlan\n<Vlan name='' vid=20>\n\n\n\n\nUpdate subnet\n\n\nQuickly move the newly created subnet from vlan to default fabric\nuntagged vlan.\n\n\n>>> default_fabric = client.fabrics.get_default()\n>>> untagged = default_fabric.vlans.get_default()\n>>> new_subnet.vlan = untagged\n>>> new_subnet.save()\n>>> new_subnet.vlan\n<Vlan name='untagged' vid=0>\n\n\n\n\nDelete subnet\n\n\ndelete\n exists directly on the \nSubnet\n object so deletion is simple.\n\n\n>>> new_subnet.delete()\n>>>\n\n\n\n\nEnable DHCP\n\n\nCreate a new dynamic IP range and turn DHCP on the selected\nrack controller.\n\n\n>>> fabric = client.fabrics.get_default()\n>>> untagged = fabric.vlans.get_default()\n>>> new_range = client.ip_ranges.create(\n...     '192.168.122.100', '192.168.122.200', type=IPRangeType.DYNAMIC)\n>>> rack = client.rack_controllers.list()[0]\n>>> untagged.dhcp_on = True\n>>> untagged.primary_rack = rack\n>>> untagged.save()",
            "title": "Networking"
        },
        {
            "location": "/client/networking/index.html#read-networking",
            "text": "fabrics ,  subnets ,  spaces ,  ip_ranges , and  static_routes  is\nexposed directly on your  Client  instance.  vlans  are nested under each Fabric .  >>> fabrics = client.fabrics.list()\n>>> len(fabrics)\n1\n>>> default_fabric = fabrics.get_default()\n>>> default_fabric.name\n'fabric-0'\n>>> default_fabric.vlans\n<Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]>\n>>> for vlan in default_fabric.vlans:\n...     print(vlan)\n...\n<Vlan name='untagged' vid=0>\n>>>  Get a specific subnet and view the  Vlan  and  Fabric  that it is\nassigned to. Going up the tree from  Vlan  to  Fabric  results in an\nunloaded  Fabric . Calling  refresh  on  Fabric  will load the object\nfrom MAAS.  >>> vm_subnet = client.subnets.get('192.168.122.0/24')\n>>> vm_subnet.cidr\n'192.168.122.0/24'\n>>> vm_subnet.vlan\n<Vlan name='untagged' vid=0>\n>>> fabric = vm_subnet.vlan.fabric\n>>> fabric\n<Fabric id=20 (unloaded)>\n>>> fabric.refresh()\n>>> fabric.vlans\nTraceback (most recent call last):\n...\nObjectNotLoaded: cannot access attribute 'vlans' of object 'Fabric'\n>>> fabric.is_loaded\nFalse\n>>> fabric.refresh()\n>>> fabric.is_loaded\nTrue\n>>> fabric.vlans\n<Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]>  Access to  spaces ,  ip_ranges , and  static_routes  works similarly.  >>> client.spaces.list()\n>>> client.ip_ranges.list()\n>>> client.static_routes.list()",
            "title": "Read networking"
        },
        {
            "location": "/client/networking/index.html#create-fabric-vlan",
            "text": "Creating a new fabric and vlan is done directly from each set of objects on\nthe  Client  respectively.  >>> new_fabric = client.fabrics.create()\n>>> new_fabric.name\n'fabric-2'\n>>> new_vlan = new_fabric.vlans.create(20)\n>>> new_vlan\n<Vlan name='' vid=20>\n>>> new_vlan.fabric\n<Fabric id=2 (unloaded)>",
            "title": "Create fabric &amp; vlan"
        },
        {
            "location": "/client/networking/index.html#create-subnet",
            "text": "Create a new subnet and assign it to an existing vlan.  >>> new_subnet = client.subnets.create('192.168.128.0/24', new_vlan)\n>>> new_subnet.cidr\n'192.168.128.0/24'\n>>> new_subnet.vlan\n<Vlan name='' vid=20>",
            "title": "Create subnet"
        },
        {
            "location": "/client/networking/index.html#update-subnet",
            "text": "Quickly move the newly created subnet from vlan to default fabric\nuntagged vlan.  >>> default_fabric = client.fabrics.get_default()\n>>> untagged = default_fabric.vlans.get_default()\n>>> new_subnet.vlan = untagged\n>>> new_subnet.save()\n>>> new_subnet.vlan\n<Vlan name='untagged' vid=0>",
            "title": "Update subnet"
        },
        {
            "location": "/client/networking/index.html#delete-subnet",
            "text": "delete  exists directly on the  Subnet  object so deletion is simple.  >>> new_subnet.delete()\n>>>",
            "title": "Delete subnet"
        },
        {
            "location": "/client/networking/index.html#enable-dhcp",
            "text": "Create a new dynamic IP range and turn DHCP on the selected\nrack controller.  >>> fabric = client.fabrics.get_default()\n>>> untagged = fabric.vlans.get_default()\n>>> new_range = client.ip_ranges.create(\n...     '192.168.122.100', '192.168.122.200', type=IPRangeType.DYNAMIC)\n>>> rack = client.rack_controllers.list()[0]\n>>> untagged.dhcp_on = True\n>>> untagged.primary_rack = rack\n>>> untagged.save()",
            "title": "Enable DHCP"
        },
        {
            "location": "/client/events/index.html",
            "text": "Events\n\n\n\nEvents are similar to other client objects\u2026 but a little different\ntoo. The only way to get events is by the \nquery\n method:\n\n\n>>> events = client.events.query()\n\n\n\n\nThis accepts a plethora of optional arguments to narrow down the results:\n\n\n>>> events = client.events.query(hostnames={\"foo\", \"bar\"})\n>>> events = client.events.query(domains={\"example.com\", \"maas.io\"})\n>>> events = client.events.query(zones=[\"red\", \"blue\"])\n>>> events = client.events.query(macs=(\"12:34:56:78:90:ab\", ))\n>>> events = client.events.query(system_ids=\u2026)\n>>> events = client.events.query(agent_name=\u2026)\n>>> events = client.events.query(level=\u2026)\n>>> events = client.events.query(after=\u2026, limit=\u2026)\n\n\n\n\nThese arguments can be combined to narrow the results even further.\n\n\nThe \nlevel\n argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are available in\n\nclient.events\n:\n\n\n>>> events = client.events.query(level=client.events.ERROR)\n\n\n\n\nbut you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/client/other/index.html",
            "text": "Other objects\n\n\n\nThere are several other object types available via the client API. Use\n\ndir()\n and tab-completion to dig around interactively, or read the\ncode; we\u2019ve tried to keep it readable.\n\n\nFiles, users, tags\n\n\nSimilarly to nodes, these sets of objects can be fetched:\n\n\n>>> tags = client.tags.list()\n>>> files = client.files.list()\n>>> users = client.users.list()\n\n\n\n\nWhen reading from collections, as above, the returned object is\nlist-like:\n\n\n>>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4\n\n\n\n\nHowever, it\u2019s read-only:\n\n\n>>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Others"
        },
        {
            "location": "/client/other/index.html#files-users-tags",
            "text": "Similarly to nodes, these sets of objects can be fetched:  >>> tags = client.tags.list()\n>>> files = client.files.list()\n>>> users = client.users.list()  When reading from collections, as above, the returned object is\nlist-like:  >>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4  However, it\u2019s read-only:  >>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Files, users, tags"
        },
        {
            "location": "/bones/index.html",
            "text": "bones\n \u2014 Low-level Python client API\n\n\n\nYou may prefer the \nhigher-level API \nviscera\n,\nbut maybe you need to do something that you can\u2019t do in \nviscera\n yet\n(please file a bug!), or you\u2019re developing \nviscera\n itself (which uses\n\nbones\n behind the scenes).\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\nfrom http import HTTPStatus\nfrom pprint import pprint\nfrom maas.client import bones\n\n# Replace \"a:b:c\" with an API key obtained from the UI at\n# http://$host:$port/MAAS/account/prefs/.\nprofile, session = bones.SessionAPI.connect(\n    \"http://localhost:5240/MAAS/\", apikey=\"a:b:c\")\n\n# Create a tag if it doesn't exist.\ntag_name = \"gryphon\"\ntag_comment = \"Gryphon's Stuff\"\ntry:\n    tag = session.Tag.read(name=tag_name)\nexcept bones.CallError as error:\n    if error.status == HTTPStatus.NOT_FOUND:\n        tag = session.Tags.new(\n            name=tag_name, comment=tag_comment)\n    else:\n        raise\n\n# List all the tags.\nprint(\">>> Tags.list()\")\npprint(session.Tags.list())\n\n# Get the system IDs for all nodes.\nprint(\">>> Nodes.list()\")\nall_nodes_system_ids = [\n    node[\"system_id\"] for node in session.Nodes.list()\n]\npprint(all_nodes_system_ids)\n\n# Associate the tag with all nodes.\nprint(\">>> Tag.update_nodes()\")\npprint(session.Tag.update_nodes(\n    name=tag[\"name\"], add=all_nodes_system_ids))",
            "title": "Bones"
        },
        {
            "location": "/bones/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5\n\nfrom http import HTTPStatus\nfrom pprint import pprint\nfrom maas.client import bones\n\n# Replace \"a:b:c\" with an API key obtained from the UI at\n# http://$host:$port/MAAS/account/prefs/.\nprofile, session = bones.SessionAPI.connect(\n    \"http://localhost:5240/MAAS/\", apikey=\"a:b:c\")\n\n# Create a tag if it doesn't exist.\ntag_name = \"gryphon\"\ntag_comment = \"Gryphon's Stuff\"\ntry:\n    tag = session.Tag.read(name=tag_name)\nexcept bones.CallError as error:\n    if error.status == HTTPStatus.NOT_FOUND:\n        tag = session.Tags.new(\n            name=tag_name, comment=tag_comment)\n    else:\n        raise\n\n# List all the tags.\nprint(\">>> Tags.list()\")\npprint(session.Tags.list())\n\n# Get the system IDs for all nodes.\nprint(\">>> Nodes.list()\")\nall_nodes_system_ids = [\n    node[\"system_id\"] for node in session.Nodes.list()\n]\npprint(all_nodes_system_ids)\n\n# Associate the tag with all nodes.\nprint(\">>> Tag.update_nodes()\")\npprint(session.Tag.update_nodes(\n    name=tag[\"name\"], add=all_nodes_system_ids))",
            "title": "Some example code"
        },
        {
            "location": "/viscera/index.html",
            "text": "viscera\n \u2014 High-level Python client API\n\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\nfrom pprint import pprint\nfrom maas.client import viscera\n\nprofile, origin = viscera.Origin.login(\n    \"http://localhost:5240/MAAS/\", username=\"alice\",\n    password=\"wonderland\")\n\n# List all the tags.\nprint(\">>> origin.Tags.read()\")\npprint(origin.Tags.read())\n\n# List all machines.\nprint(\">>> origin.Machines.read()\")\npprint(origin.Machines.read())",
            "title": "Introduction"
        },
        {
            "location": "/viscera/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5\n\nfrom pprint import pprint\nfrom maas.client import viscera\n\nprofile, origin = viscera.Origin.login(\n    \"http://localhost:5240/MAAS/\", username=\"alice\",\n    password=\"wonderland\")\n\n# List all the tags.\nprint(\">>> origin.Tags.read()\")\npprint(origin.Tags.read())\n\n# List all machines.\nprint(\">>> origin.Machines.read()\")\npprint(origin.Machines.read())",
            "title": "Some example code"
        },
        {
            "location": "/viscera/getting-started/index.html",
            "text": "Getting started with \nviscera\n\n\n\nLogging-in\n\n\nLog-in using the command-line tool and start an interactive Python\nshell:\n\n\n$ maas profiles login foo http://example.com:5240/MAAS/ admin\nPassword: \u2026\n$ maas shell\n\n\n\n\nThis will provide you with a pre-prepared \norigin\n object that points to\n\nfoo\n from above. This is the root object of the API.\n\n\nIf you have MAAS 2.2 or later you can also log-in programmatically:\n\n\n>>> profile, origin = Origin.login(\n...     \"http://example.com:5240/MAAS/\", username=\"admin\",\n...     password=\"\u2026\")\n\n\n\n\nThe \nprofile\n has not been saved, but it\u2019s easy to do so:\n\n\n>>> profile = profile.replace(name=\"foo\")\n>>> with ProfileStore.open() as store:\n...     store.save(profile)\n...     store.default = profile\n\n\n\n\nThis does the same as the \nmaas profiles login\n command.\n\n\nBut there\u2019s no need! There\u2019s a command built in to do it for you:\n\n\n$ bin/maas shell\nWelcome to the MAAS shell.\n\nPredefined variables:\n\n    origin: A `viscera` origin, configured for foo.\n   session: A `bones` session, configured for foo.\n\n>>>\n\n\n\n\nLogging-out\n\n\nLog-out using the command-line tool:\n\n\n$ bin/maas profiles remove foo\n\n\n\n\nor, programmatically:\n\n\n>>> with ProfileStore.open() as store:\n...     store.delete(\"foo\")\n\n\n\n\ndir()\n, \nhelp()\n, and tab-completion\n\n\nThe \nviscera\n API has been designed to be very discoverable using\ntab-completion, \ndir()\n, \nhelp()\n, and so on. Start with that:\n\n\n>>> origin.<tab>\n\u2026\n\n\n\n\nThis works best when you\u2019ve got \nIPython\n\ninstalled.",
            "title": "Getting started"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-in",
            "text": "Log-in using the command-line tool and start an interactive Python\nshell:  $ maas profiles login foo http://example.com:5240/MAAS/ admin\nPassword: \u2026\n$ maas shell  This will provide you with a pre-prepared  origin  object that points to foo  from above. This is the root object of the API.  If you have MAAS 2.2 or later you can also log-in programmatically:  >>> profile, origin = Origin.login(\n...     \"http://example.com:5240/MAAS/\", username=\"admin\",\n...     password=\"\u2026\")  The  profile  has not been saved, but it\u2019s easy to do so:  >>> profile = profile.replace(name=\"foo\")\n>>> with ProfileStore.open() as store:\n...     store.save(profile)\n...     store.default = profile  This does the same as the  maas profiles login  command.  But there\u2019s no need! There\u2019s a command built in to do it for you:  $ bin/maas shell\nWelcome to the MAAS shell.\n\nPredefined variables:\n\n    origin: A `viscera` origin, configured for foo.\n   session: A `bones` session, configured for foo.\n\n>>>",
            "title": "Logging-in"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-out",
            "text": "Log-out using the command-line tool:  $ bin/maas profiles remove foo  or, programmatically:  >>> with ProfileStore.open() as store:\n...     store.delete(\"foo\")",
            "title": "Logging-out"
        },
        {
            "location": "/viscera/getting-started/index.html#dir-help-and-tab-completion",
            "text": "The  viscera  API has been designed to be very discoverable using\ntab-completion,  dir() ,  help() , and so on. Start with that:  >>> origin.<tab>\n\u2026  This works best when you\u2019ve got  IPython \ninstalled.",
            "title": "dir(), help(), and tab-completion"
        },
        {
            "location": "/viscera/nodes/index.html",
            "text": "Machines, devices, racks, and regions\n\n\n\nGiven an \nOrigin\n instance bound to your MAAS server, you can\ninterrogate your nodes with:\n\n\norigin.Machines.read()\n  # returns an origin.Machines instance, a\n  # sequence of origin.Machine instances.\n\norigin.Devices.read()\n  # returns an origin.Devices instance, a\n  # sequence of origin.Device instances.\n\norigin.RackControllers.read()\n  # returns an origin.RackControllers instance, a\n  # sequence of origin.RackController instances.\n\norigin.RegionControllers.read()\n  # returns an origin.RegionControllers instance, a\n  # sequence of origin.RegionController instances.\n\n\n\n\nAn example\n\n\n>>> for machine in origin.Machines.read():\n...     print(repr(node))\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nIndividual nodes can be read from the Web API.\n\n\n>>> machine = origin.Machine.read(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nMachines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:\n\n\n>>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4\n>>> for interface in machine.interfaces:\n...     print(repr(Interface))\n<Interface name='eth0' mac_address='00:11:22:33:44:55'>\n<Interface name='eth1' mac_address='00:11:22:33:44:66'>\n\n\n\n\nDon\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or\n\ndir(machine)\n to find out what other fields and methods are\navailable.\n\n\nTODO\n: Updating nodes.\n\n\nAllocating and deploying\n\n\n>>> help(origin.Machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = origin.Machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status_name)\nAcquired\n>>> machine.deploy()\n>>> print(machine.status_name)\nDeploying",
            "title": "Nodes"
        },
        {
            "location": "/viscera/nodes/index.html#an-example",
            "text": ">>> for machine in origin.Machines.read():\n...     print(repr(node))\n<Machine hostname='botswana' system_id='pncys4'>  Individual nodes can be read from the Web API.  >>> machine = origin.Machine.read(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>  Machines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:  >>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4\n>>> for interface in machine.interfaces:\n...     print(repr(Interface))\n<Interface name='eth0' mac_address='00:11:22:33:44:55'>\n<Interface name='eth1' mac_address='00:11:22:33:44:66'>  Don\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or dir(machine)  to find out what other fields and methods are\navailable.  TODO : Updating nodes.",
            "title": "An example"
        },
        {
            "location": "/viscera/nodes/index.html#allocating-and-deploying",
            "text": ">>> help(origin.Machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = origin.Machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status_name)\nAcquired\n>>> machine.deploy()\n>>> print(machine.status_name)\nDeploying",
            "title": "Allocating and deploying"
        },
        {
            "location": "/viscera/events/index.html",
            "text": "Events\n\n\n\nEvents are similar to other \nviscera\n objects\u2026 but a little different\ntoo. The only way to get events is by the \nquery\n method:\n\n\n>>> events = origin.Events.query()\n\n\n\n\nThis accepts a plethora of optional arguments to narrow down the results:\n\n\n>>> events = origin.Events.query(hostnames={\"foo\", \"bar\"})\n>>> events = origin.Events.query(domains={\"example.com\", \"maas.io\"})\n>>> events = origin.Events.query(zones=[\"red\", \"blue\"])\n>>> events = origin.Events.query(macs=(\"12:34:56:78:90:ab\", ))\n>>> events = origin.Events.query(system_ids=\u2026)\n>>> events = origin.Events.query(agent_name=\u2026)\n>>> events = origin.Events.query(level=\u2026)\n>>> events = origin.Events.query(after=\u2026, limit=\u2026)\n\n\n\n\nThese arguments can be combined to narrow the results even further.\n\n\nThe \nlevel\n argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are defined in the\n\nLevel\n enum:\n\n\n>>> events = origin.Events.query(level=origin.Events.Level.ERROR)\n\n\n\n\nbut you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/viscera/other/index.html",
            "text": "Other objects\n\n\n\nThere are several other object types available via \nviscera\n. Use\n\ndir()\n and tab-completion to dig around interactively, or read the\ncode; we\u2019ve tried to keep it readable.\n\n\nFiles, users, tags\n\n\nSimilarly to nodes, these sets of objects can be fetched:\n\n\n>>> tags = origin.Tags.read()\n>>> files = origin.Files.read()\n>>> users = origin.Users.read()\n\n\n\n\nWhen reading from collections, as above, the returned object is\nlist-like:\n\n\n>>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4\n\n\n\n\nHowever, it\u2019s read-only:\n\n\n>>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Others"
        },
        {
            "location": "/viscera/other/index.html#files-users-tags",
            "text": "Similarly to nodes, these sets of objects can be fetched:  >>> tags = origin.Tags.read()\n>>> files = origin.Files.read()\n>>> users = origin.Users.read()  When reading from collections, as above, the returned object is\nlist-like:  >>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4  However, it\u2019s read-only:  >>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Files, users, tags"
        },
        {
            "location": "/development/releasing/index.html",
            "text": "Releasing a new version of \npython-libmaas\n\n\n\n\n\n\n\nClean and test:\n\n\nmake clean\nmake test\n\n\n\n\n\n\n\n\nIf you didn\u2019t \nmake clean\n just now, do it! Without it the \nPyPI\n\n   uploads may be built incorrectly.\n\n\n\n\n\n\nBump version in \nsetup.py\n, merge to \nmaster\n.\n\n\n\n\n\n\nTag \nmaster\n:\n\n\ngit tag --sign ${version} --message \"Release ${version}.\"\ngit push origin --tags\n\n\n\n\n\n\n\n\nBuild and push docs to \nGitHub\n:\n\n\nmake docs-to-github\n\n\n\n\n\n\n\n\nBuild and push source and wheel to \nPyPI\n:\n\n\nmake upload",
            "title": "Release checklist"
        },
        {
            "location": "/development/adding-an-object/index.html",
            "text": "Adding a new object type\n\n\n\nThis will show the process by which we can add support for \nSpace\n\nobjects, but it should be roughly applicable to other objects.\n\n\n\n\nSkeleton\n\n\nStart by creating a new file in \nviscera\n. Following the example of\nexisting objects, name it \nmaas/client/viscera/spaces.py\n (i.e. plural).\n\n\n\n\nWhy \nviscera\n? The client we recommend for users is a fa\u00e7ade of\n\nviscera\n, allowing us to present a simplified interface which mingles\nset-like operations with individual ones. This is friendlier to a new\ndeveloper, but \nviscera\n itself keeps the two separate for cleanliness\nof implementation.\n\n\n\n\nCreate a skeleton for \nSpace\n and \nSpaces\n:\n\n\n\"\"\"Objects for spaces.\"\"\"\n\n__all__ = [\n    \"Space\",\n    \"Spaces\",\n]\n\nfrom . import (\n    Object,\n    ObjectSet,\n    ObjectType,\n)\n\n\nclass SpacesType(ObjectType):\n    \"\"\"Metaclass for `Spaces`.\"\"\"\n\n\nclass Spaces(ObjectSet, metaclass=SpacesType):\n    \"\"\"The set of spaces.\"\"\"\n\n\nclass SpaceType(ObjectType):\n    \"\"\"Metaclass for `Space`.\"\"\"\n\n\nclass Space(Object, metaclass=SpaceType):\n    \"\"\"A space.\"\"\"\n\n\n\n\nWe create explicit type classes as a place to put class-specific\ninformation and methods. Most interestingly, methods created on the type\nclasses are \nclass\n methods on instances of the type. For example:\n\n\n>>> class FooType(type):\n...    def hello(cls):\n...        return \"Hello, %s\" % cls\n\n>>> class Foo(metaclass=FooType):\n...    def goodbye(self):\n...        return \"Goodbye, %s\" % self\n\n>>> Foo.hello()\n\"Hello, <class '__main__.Foo'>\"\n\n>>> foo = Foo()\n>>> foo.goodbye()\n'Goodbye, <__main__.Foo object at ...>'\n\n\n\n\nThe difference between using \n@classmethod\n and this is that those class\nmethods are not available on instances:\n\n\n>>> foo.hello()\nTraceback (most recent call last):\n...\nAttributeError: 'Foo' object has no attribute 'hello'\n\n\n\n\nThis keeps the namespace uncluttered, which is good for interactive,\nexploratory development, and it keeps code cleaner too: a class method\n\nmust\n be called via the class.\n\n\nGetting this into the default \nOrigin\n\n\nIn \nmaas/client/viscera/__init__.py\n is the default \nOrigin\n class. This\nloads object definitions, like those above, and \nbinds\n them to a\nparticular server. More about that later, but for now you need to add\n\n\".spaces\"\n to \nOrigin.__init__\n:\n\n\n             \".files\",\n             \".maas\",\n             \".machines\",\n+            \".spaces\",\n             \".tags\",\n             \".users\",\n             \".version\",\n\n\n\n\nBasic accessors\n\n\nAdd the following basic accessor method to \nSpacesType\n:\n\n\nclass SpacesType(ObjectType):\n\n    async def read(cls):\n        data = await cls._handler.read()\n        return cls(map(cls._object, data))\n\n\n\n\nLet\u2019s start working against a real MAAS server:\n\n\n$ bin/maas login my-server http://.../MAAS username p4ssw0rd\n$ bin/pip install -IU IPython  # Don't leave home without it.\n$ bin/maas shell --viscera\nWelcome to the MAAS shell.\n\nPredefined objects:\n\n  client:\n    A pre-canned client for 'madagascar'.\n\n  origin:\n    A pre-canned `viscera` origin for 'madagascar'.\n\n\n\n\n>>> origin.Spaces.read()\n<Spaces length=2 items=[<Space>, <Space>]>\n\n>>> origin.Spaces._handler\n<Handler Spaces http://.../MAAS/api/2.0/spaces/>\n\n>>> origin.Spaces._origin\n<maas.client.viscera.Origin at ...>\n\n\n\n\nThe \n_handler\n attribute is the \nbones\n handler for spaces. We named the\nclass \u201cSpaces\u201d and \nOrigin\n paired that up with the \nbones\n handler of\nthe same name. This let us call the lower-level \nread()\n method. Try\ncalling it now:\n\n\n>>> origin.Spaces._handler.read()\n[{'id': 0,\n  'name': 'space-0',\n  'resource_uri': '/MAAS/api/2.0/spaces/0/',\n  'subnets': [],\n  'vlans': []},\n {'id': -1,\n  'name': 'undefined',\n  'resource_uri': '/MAAS/api/2.0/spaces/undefined/',\n  'subnets': [{'active_discovery': False,\n    'allow_proxy': True,\n    'cidr': '192.168.1.0/24',\n    'dns_servers': [],\n    'gateway_ip': '192.168.1.254',\n    'id': 1,\n    'managed': True,\n    'name': '192.168.1.0/24',\n    'rdns_mode': 2,\n    'resource_uri': '/MAAS/api/2.0/subnets/1/',\n    'space': 'undefined',\n    'vlan': {'dhcp_on': True,\n     'external_dhcp': None,\n     'fabric': 'fabric-0',\n     'fabric_id': 0,\n     'id': 5001,\n     'mtu': 1500,\n     'name': 'untagged',\n     'primary_rack': '4y3h7n',\n     'relay_vlan': None,\n     'resource_uri': '/MAAS/api/2.0/vlans/5001/',\n     'secondary_rack': 'xfaxgw',\n     'space': 'undefined',\n     'vid': 0}}],\n  'vlans': [{'dhcp_on': True,\n    'external_dhcp': None,\n    'fabric': 'fabric-0',\n    'fabric_id': 0,\n    'id': 5001,\n    'mtu': 1500,\n    'name': 'untagged',\n    'primary_rack': '4y3h7n',\n    'relay_vlan': None,\n    'resource_uri': '/MAAS/api/2.0/vlans/5001/',\n    'secondary_rack': 'xfaxgw',\n    'space': 'undefined',\n    'vid': 0}]}]\n\n\n\n\nLots of information!\n\n\n\n\nBy the way, many or most of the IO methods in \npython-libmaas\n can be\ncalled interactively or in a script and they work the same as any\nother synchronous or blocking call. Internally, however, they\u2019re all\nasynchronous. They\u2019re wrapped in such a way that, when called from\noutside of an \nasyncio\n event-loop, they block, but inside they work\njust the same as any other asynchronous call.\n\n\n\n\nLet\u2019s look at those \nSpace\n objects:\n\n\n>>> space, *_ = origin.Spaces.read()\n\n>>> dir(space)\n[..., '_data', '_handler', '_origin']\n\n>>> space._data\n{'id': 0,\n 'name': 'space-0',\n 'resource_uri': '/MAAS/api/2.0/spaces/0/',\n 'subnets': [],\n 'vlans': []}\n\n>>> space._handler\n<Handler Space http://madagascar.local:5240/MAAS/api/2.0/spaces/{space_id}/>\n\n>>> space._origin is origin\nTrue\n\n\n\n\nThe handler has been associated with this object type like it was for\n\nSpaces\n, so now\u2019s a good time to add another accessor method:\n\n\nclass SpaceType(ObjectType):\n\n    async def read(cls):\n        data = await cls._handler.read()\n        return cls(data)\n\n\n\n\nTry it out:\n\n\n>>> space = origin.Space.read(0)\n\n>>> space._data\n{'id': 0,\n 'name': 'space-0',\n 'resource_uri': '/MAAS/api/2.0/spaces/0/',\n 'subnets': [],\n 'vlans': []}\n\n\n\n\nGetting at the data\n\n\nWe don\u2019t want to work with that \n_data\n dictionary, we want attributes:\n\n\nclass Space(Object, metaclass=SpaceType):\n    \"\"\"A space.\"\"\"\n\n    id = ObjectField.Checked(\"id\", check(int), readonly=True)\n    name = ObjectField.Checked(\"name\", check(str), readonly=True)\n\n\n\n\nTry it out in the shell:\n\n\n>>> space.id, space, name\n(0, 'space-0')\n\n\n\n\nNext steps\n\n\nThat\u2019s enough for now, but there\u2019s plenty of ground yet to be covered:\n\n\n\n\n\n\nHow to work with the information about subnets and VLANs data that was\n  returned.\n\n\n\n\n\n\nHow to create, modify, and delete objects.\n\n\n\n\n\n\nHow to test all of this.",
            "title": "Adding an object"
        },
        {
            "location": "/development/adding-an-object/index.html#skeleton",
            "text": "Start by creating a new file in  viscera . Following the example of\nexisting objects, name it  maas/client/viscera/spaces.py  (i.e. plural).   Why  viscera ? The client we recommend for users is a fa\u00e7ade of viscera , allowing us to present a simplified interface which mingles\nset-like operations with individual ones. This is friendlier to a new\ndeveloper, but  viscera  itself keeps the two separate for cleanliness\nof implementation.   Create a skeleton for  Space  and  Spaces :  \"\"\"Objects for spaces.\"\"\"\n\n__all__ = [\n    \"Space\",\n    \"Spaces\",\n]\n\nfrom . import (\n    Object,\n    ObjectSet,\n    ObjectType,\n)\n\n\nclass SpacesType(ObjectType):\n    \"\"\"Metaclass for `Spaces`.\"\"\"\n\n\nclass Spaces(ObjectSet, metaclass=SpacesType):\n    \"\"\"The set of spaces.\"\"\"\n\n\nclass SpaceType(ObjectType):\n    \"\"\"Metaclass for `Space`.\"\"\"\n\n\nclass Space(Object, metaclass=SpaceType):\n    \"\"\"A space.\"\"\"  We create explicit type classes as a place to put class-specific\ninformation and methods. Most interestingly, methods created on the type\nclasses are  class  methods on instances of the type. For example:  >>> class FooType(type):\n...    def hello(cls):\n...        return \"Hello, %s\" % cls\n\n>>> class Foo(metaclass=FooType):\n...    def goodbye(self):\n...        return \"Goodbye, %s\" % self\n\n>>> Foo.hello()\n\"Hello, <class '__main__.Foo'>\"\n\n>>> foo = Foo()\n>>> foo.goodbye()\n'Goodbye, <__main__.Foo object at ...>'  The difference between using  @classmethod  and this is that those class\nmethods are not available on instances:  >>> foo.hello()\nTraceback (most recent call last):\n...\nAttributeError: 'Foo' object has no attribute 'hello'  This keeps the namespace uncluttered, which is good for interactive,\nexploratory development, and it keeps code cleaner too: a class method must  be called via the class.",
            "title": "Skeleton"
        },
        {
            "location": "/development/adding-an-object/index.html#getting-this-into-the-default-origin",
            "text": "In  maas/client/viscera/__init__.py  is the default  Origin  class. This\nloads object definitions, like those above, and  binds  them to a\nparticular server. More about that later, but for now you need to add \".spaces\"  to  Origin.__init__ :               \".files\",\n             \".maas\",\n             \".machines\",\n+            \".spaces\",\n             \".tags\",\n             \".users\",\n             \".version\",",
            "title": "Getting this into the default Origin"
        },
        {
            "location": "/development/adding-an-object/index.html#basic-accessors",
            "text": "Add the following basic accessor method to  SpacesType :  class SpacesType(ObjectType):\n\n    async def read(cls):\n        data = await cls._handler.read()\n        return cls(map(cls._object, data))  Let\u2019s start working against a real MAAS server:  $ bin/maas login my-server http://.../MAAS username p4ssw0rd\n$ bin/pip install -IU IPython  # Don't leave home without it.\n$ bin/maas shell --viscera\nWelcome to the MAAS shell.\n\nPredefined objects:\n\n  client:\n    A pre-canned client for 'madagascar'.\n\n  origin:\n    A pre-canned `viscera` origin for 'madagascar'.  >>> origin.Spaces.read()\n<Spaces length=2 items=[<Space>, <Space>]>\n\n>>> origin.Spaces._handler\n<Handler Spaces http://.../MAAS/api/2.0/spaces/>\n\n>>> origin.Spaces._origin\n<maas.client.viscera.Origin at ...>  The  _handler  attribute is the  bones  handler for spaces. We named the\nclass \u201cSpaces\u201d and  Origin  paired that up with the  bones  handler of\nthe same name. This let us call the lower-level  read()  method. Try\ncalling it now:  >>> origin.Spaces._handler.read()\n[{'id': 0,\n  'name': 'space-0',\n  'resource_uri': '/MAAS/api/2.0/spaces/0/',\n  'subnets': [],\n  'vlans': []},\n {'id': -1,\n  'name': 'undefined',\n  'resource_uri': '/MAAS/api/2.0/spaces/undefined/',\n  'subnets': [{'active_discovery': False,\n    'allow_proxy': True,\n    'cidr': '192.168.1.0/24',\n    'dns_servers': [],\n    'gateway_ip': '192.168.1.254',\n    'id': 1,\n    'managed': True,\n    'name': '192.168.1.0/24',\n    'rdns_mode': 2,\n    'resource_uri': '/MAAS/api/2.0/subnets/1/',\n    'space': 'undefined',\n    'vlan': {'dhcp_on': True,\n     'external_dhcp': None,\n     'fabric': 'fabric-0',\n     'fabric_id': 0,\n     'id': 5001,\n     'mtu': 1500,\n     'name': 'untagged',\n     'primary_rack': '4y3h7n',\n     'relay_vlan': None,\n     'resource_uri': '/MAAS/api/2.0/vlans/5001/',\n     'secondary_rack': 'xfaxgw',\n     'space': 'undefined',\n     'vid': 0}}],\n  'vlans': [{'dhcp_on': True,\n    'external_dhcp': None,\n    'fabric': 'fabric-0',\n    'fabric_id': 0,\n    'id': 5001,\n    'mtu': 1500,\n    'name': 'untagged',\n    'primary_rack': '4y3h7n',\n    'relay_vlan': None,\n    'resource_uri': '/MAAS/api/2.0/vlans/5001/',\n    'secondary_rack': 'xfaxgw',\n    'space': 'undefined',\n    'vid': 0}]}]  Lots of information!   By the way, many or most of the IO methods in  python-libmaas  can be\ncalled interactively or in a script and they work the same as any\nother synchronous or blocking call. Internally, however, they\u2019re all\nasynchronous. They\u2019re wrapped in such a way that, when called from\noutside of an  asyncio  event-loop, they block, but inside they work\njust the same as any other asynchronous call.   Let\u2019s look at those  Space  objects:  >>> space, *_ = origin.Spaces.read()\n\n>>> dir(space)\n[..., '_data', '_handler', '_origin']\n\n>>> space._data\n{'id': 0,\n 'name': 'space-0',\n 'resource_uri': '/MAAS/api/2.0/spaces/0/',\n 'subnets': [],\n 'vlans': []}\n\n>>> space._handler\n<Handler Space http://madagascar.local:5240/MAAS/api/2.0/spaces/{space_id}/>\n\n>>> space._origin is origin\nTrue  The handler has been associated with this object type like it was for Spaces , so now\u2019s a good time to add another accessor method:  class SpaceType(ObjectType):\n\n    async def read(cls):\n        data = await cls._handler.read()\n        return cls(data)  Try it out:  >>> space = origin.Space.read(0)\n\n>>> space._data\n{'id': 0,\n 'name': 'space-0',\n 'resource_uri': '/MAAS/api/2.0/spaces/0/',\n 'subnets': [],\n 'vlans': []}",
            "title": "Basic accessors"
        },
        {
            "location": "/development/adding-an-object/index.html#getting-at-the-data",
            "text": "We don\u2019t want to work with that  _data  dictionary, we want attributes:  class Space(Object, metaclass=SpaceType):\n    \"\"\"A space.\"\"\"\n\n    id = ObjectField.Checked(\"id\", check(int), readonly=True)\n    name = ObjectField.Checked(\"name\", check(str), readonly=True)  Try it out in the shell:  >>> space.id, space, name\n(0, 'space-0')",
            "title": "Getting at the data"
        },
        {
            "location": "/development/adding-an-object/index.html#next-steps",
            "text": "That\u2019s enough for now, but there\u2019s plenty of ground yet to be covered:    How to work with the information about subnets and VLANs data that was\n  returned.    How to create, modify, and delete objects.    How to test all of this.",
            "title": "Next steps"
        }
    ]
}