{
    "docs": [
        {
            "location": "/index.html",
            "text": "Welcome to MAAS\u2019s new command-line tool & Python client libraries\n\n\npython-libmaas\n provides:\n\n\n\n\n\n\nA rich and stable Python client library for interacting with MAAS 2.0+\n  servers. This can be used in a synchronous/blocking mode, or an\n  asynchronous/non-blocking mode based on \nasyncio\n.\n\n\n\n\n\n\nA lower-level Python client library, auto-generated to match the MAAS\n  server it\u2019s interacting with.\n\n\n\n\n\n\nA command-line tool for working with MAAS servers.\n\n\n\n\n\n\nFor MAAS \nserver\n documentation, visit\n\ndocs.ubuntu.com\n.\n\n\nInstallation\n\n\nEither work from a branch:\n\n\n$\n git clone https://github.com/maas/python-libmaas.git\n\n$\n \ncd\n python-libmaas\n\n$\n make\n\n\n\n\n\nOr install with \npip\n into a\n\nvirtualenv\n:\n\n\n$\n virtualenv --python\n=\npython3.5 amc \n&&\n \nsource\n amc/bin/activate\n\n$\n pip install git+https://github.com/maas/python-libmaas.git\n\n\n\n\n\nOr install from \nPyPI\n:\n\n\n$\n virtualenv --python\n=\npython3.5 amc \n&&\n \nsource\n amc/bin/activate\n\n$\n pip install python-libmaas\n\n\n\n\n\nNote\n that PyPI may lag the others.\n\n\nThis documentation assumes you\u2019re working from a branch or in a\nvirtualenv. In practice this means it will use partially qualified paths\nlike \nbin/maas\n instead of bare \nmaas\n invocations. If you\u2019ve\ninstalled from PyPI the \nmaas\n command will probably be installed on\nyour shell\u2019s \nPATH\n so you can invoke it as \nmaas\n.\n\n\nCommand-line\n\n\n$\n bin/maas profiles login --help\n\n$\n bin/maas profiles login exmpl \n\\\n\n>   http://example.com:5240/MAAS/ my_username\n\nPassword: \u2026\n\n\n$\n bin/maas list\n\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\n\n\u2502   \u2502 Hostname   \u2502 System ID \u2502 #CPUs \u2502 RAM    \u2502 Status \u2502 Power   \u2502\n\n\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502 m \u2502 botswana   \u2502 pncys4    \u2502 4     \u2502 8.0 GB \u2502 Ready  \u2502 Off     \u2502\n\n\n\u2502 c \u2502 namibia    \u2502 xfaxgw    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Error   \u2502\n\n\n\u2502 C \u2502 madagascar \u2502 4y3h7n    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Unknown \u2502\n\n\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n\n\n\n\nClient library\n\n\nThe simplest entry points into \npython-libmaas\n are the \nconnect\n\nand \nlogin\n functions in \nmaas.client\n. The former connects to a\nMAAS server using a previously obtained API key, and the latter logs-in\nto MAAS with your username and password. These returns a \nClient\n\nobject that has convenient attributes for working with MAAS. For\nexample, to print out a few recent events:\n\n\nfrom\n \nmaas.client\n \nimport\n \nlogin\n\n\nclient\n \n=\n \nlogin\n(\n\n    \n\"http://localhost:5240/MAAS/\"\n,\n\n    \nusername\n=\n\"my_user\"\n,\n \npassword\n=\n\"my_pass\"\n,\n\n\n)\n\n\ntmpl\n \n=\n \n(\n\n    \n\"{0.created:%Y-%m-\n%d\n %H:%M:%S} \"\n\n    \n\"{0.level.name} {0.description_short}\"\n\n\n)\n\n\nfor\n \nevent\n \nin\n \nclient\n.\nevents\n.\nquery\n():\n\n    \nprint\n(\ntmpl\n.\nformat\n(\nevent\n))\n\n\n\n\n\n\nLearn more about the \nclient\n.\n\n\nBones\n & \nviscera\n\n\nThe primary client is based on two underlying libraries:\n\n\n\n\n\n\nA lower-level library that closely mirrors MAAS\u2019s Web API, referred to\n  as \nbones\n. The MAAS server publishes a description of its Web API and\n  \nbones\n provides a convenient mechanism to interact with it.\n\n\n\n\n\n\nA higher-level library that\u2019s designed for developers, referred to as\n  \nviscera\n. MAAS\u2019s Web API is sometimes unfriendly or inconsistent, but\n  \nviscera\n presents a hand-crafted API specifically \ndesigned\n for\n  developers rather than machines.\n\n\n\n\n\n\nThe implementation of \nviscera\n makes use of\n\nbones\n.\n\n\nTry this next: \nGet started with \nviscera\n\n\nShell\n\n\nThere\u2019s an interactive shell too. This imports some convenient bits into\nthe default namespace, and creates a \nviscera\n \nOrigin\n instance and a\n\nbones\n \nSessionAPI\n instance bound to the currently selected profile.\n\n\nFor the best experience install \nIPython\n first.\n\n\n$\n bin/maas shell\n\nWelcome to the MAAS shell.\n\n\n...\n\n\n\n\n\n\n>>> \norigin\n.\nVersion\n.\nread\n()\n\n\n<Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]>",
            "title": "Home"
        },
        {
            "location": "/index.html#welcome-to-maass-new-command-line-tool-python-client-libraries",
            "text": "python-libmaas  provides:    A rich and stable Python client library for interacting with MAAS 2.0+\n  servers. This can be used in a synchronous/blocking mode, or an\n  asynchronous/non-blocking mode based on  asyncio .    A lower-level Python client library, auto-generated to match the MAAS\n  server it\u2019s interacting with.    A command-line tool for working with MAAS servers.    For MAAS  server  documentation, visit docs.ubuntu.com .",
            "title": "Welcome to MAAS's new command-line tool &amp; Python client libraries"
        },
        {
            "location": "/index.html#installation",
            "text": "Either work from a branch:  $  git clone https://github.com/maas/python-libmaas.git $   cd  python-libmaas $  make  Or install with  pip  into a virtualenv :  $  virtualenv --python = python3.5 amc  &&   source  amc/bin/activate $  pip install git+https://github.com/maas/python-libmaas.git  Or install from  PyPI :  $  virtualenv --python = python3.5 amc  &&   source  amc/bin/activate $  pip install python-libmaas  Note  that PyPI may lag the others.  This documentation assumes you\u2019re working from a branch or in a\nvirtualenv. In practice this means it will use partially qualified paths\nlike  bin/maas  instead of bare  maas  invocations. If you\u2019ve\ninstalled from PyPI the  maas  command will probably be installed on\nyour shell\u2019s  PATH  so you can invoke it as  maas .",
            "title": "Installation"
        },
        {
            "location": "/index.html#command-line",
            "text": "$  bin/maas profiles login --help $  bin/maas profiles login exmpl  \\ \n>   http://example.com:5240/MAAS/ my_username Password: \u2026  $  bin/maas list \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502 Hostname   \u2502 System ID \u2502 #CPUs \u2502 RAM    \u2502 Status \u2502 Power   \u2502  \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502 m \u2502 botswana   \u2502 pncys4    \u2502 4     \u2502 8.0 GB \u2502 Ready  \u2502 Off     \u2502  \u2502 c \u2502 namibia    \u2502 xfaxgw    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Error   \u2502  \u2502 C \u2502 madagascar \u2502 4y3h7n    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Unknown \u2502  \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
            "title": "Command-line"
        },
        {
            "location": "/index.html#client-library",
            "text": "The simplest entry points into  python-libmaas  are the  connect \nand  login  functions in  maas.client . The former connects to a\nMAAS server using a previously obtained API key, and the latter logs-in\nto MAAS with your username and password. These returns a  Client \nobject that has convenient attributes for working with MAAS. For\nexample, to print out a few recent events:  from   maas.client   import   login  client   =   login ( \n     \"http://localhost:5240/MAAS/\" , \n     username = \"my_user\" ,   password = \"my_pass\" ,  )  tmpl   =   ( \n     \"{0.created:%Y-%m- %d  %H:%M:%S} \" \n     \"{0.level.name} {0.description_short}\"  )  for   event   in   client . events . query (): \n     print ( tmpl . format ( event ))   Learn more about the  client .",
            "title": "Client library"
        },
        {
            "location": "/index.html#bones-viscera",
            "text": "The primary client is based on two underlying libraries:    A lower-level library that closely mirrors MAAS\u2019s Web API, referred to\n  as  bones . The MAAS server publishes a description of its Web API and\n   bones  provides a convenient mechanism to interact with it.    A higher-level library that\u2019s designed for developers, referred to as\n   viscera . MAAS\u2019s Web API is sometimes unfriendly or inconsistent, but\n   viscera  presents a hand-crafted API specifically  designed  for\n  developers rather than machines.    The implementation of  viscera  makes use of bones .  Try this next:  Get started with  viscera",
            "title": "Bones &amp; viscera"
        },
        {
            "location": "/index.html#shell",
            "text": "There\u2019s an interactive shell too. This imports some convenient bits into\nthe default namespace, and creates a  viscera   Origin  instance and a bones   SessionAPI  instance bound to the currently selected profile.  For the best experience install  IPython  first.  $  bin/maas shell Welcome to the MAAS shell.  ...   >>>  origin . Version . read ()  <Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]>",
            "title": "Shell"
        },
        {
            "location": "/client/index.html",
            "text": "The Web API client\n\n\nCalling \nmaas.client.login\n or \nmaas.client.connect\n will return a\n\nmaas.client.facade.Client\n instance. This provides an easy to\nunderstand starting point for working with MAAS\u2019s Web API.\n\n\nAn example\n\n\n#!/usr/bin/env python3.5\n\n\n\nfrom\n \nmaas.client\n \nimport\n \nlogin\n\n\n\nclient\n \n=\n \nlogin\n(\n\n    \n\"http://localhost:5240/MAAS/\"\n,\n\n    \nusername\n=\n\"foo\"\n,\n \npassword\n=\n\"bar\"\n,\n\n\n)\n\n\n\n# Get a reference to self.\n\n\nmyself\n \n=\n \nclient\n.\nusers\n.\nwhoami\n()\n\n\nassert\n \nmyself\n.\nis_admin\n,\n \n\"\n%s\n is not an admin\"\n \n%\n \nmyself\n.\nusername\n\n\n\n# Check for a MAAS server capability.\n\n\nversion\n \n=\n \nclient\n.\nversion\n.\nget\n()\n\n\nassert\n \n\"devices-management\"\n \nin\n \nversion\n.\ncapabilities\n\n\n\n# Check the default OS and distro series for deployments.\n\n\nprint\n(\nclient\n.\nmaas\n.\nget_default_os\n())\n\n\nprint\n(\nclient\n.\nmaas\n.\nget_default_distro_series\n())\n\n\n\n# Set the HTTP proxy.\n\n\nclient\n.\nmaas\n.\nset_http_proxy\n(\n\"http://localhost:3128\"\n)\n\n\n\n# Allocate and deploy a machine.\n\n\nmachine\n \n=\n \nclient\n.\nmachines\n.\nallocate\n()\n\n\nmachine\n.\ndeploy\n()\n\n\n\n\n\n\nAgain, but asynchronous\n\n\nAt first glance \npython-libmaas\n appears to be a blocking API, but it\u2019s\nactually asynchronous under the skin, based on \nasyncio\n. If you call\ninto \npython-libmaas\n from within a running event loop it will behave\nasynchronously, but called from outside it behaves synchronously, and\nblocks.\n\n\nUsing \npython-libmaas\n interactively, when exploring the library or\ntrying something out, is familiar and natural because it behaves as a\nsynchronous, blocking API. This mode can be used of in scripts too, but\nthe same code can be easily repurposed for use in an asynchronous,\nnon-blocking application.\n\n\nBelow shows the earlier example but implemented in an asynchronous\nstyle. Note the use of the \nasynchronous\n decorator: this is used\nheavily in \npython-libmaas\n \u2014 along with the \nAsynchronous\n metaclass\n\u2014 to create the automatic blocking/not-blocking behaviour.\n\n\n#!/usr/bin/env python3.5\n\n\n\nfrom\n \nmaas.client\n \nimport\n \nlogin\n\n\nfrom\n \nmaas.client.utils.async\n \nimport\n \nasynchronous\n\n\n\n@asynchronous\n\n\nasync\n \ndef\n \nwork_with_maas\n():\n\n    \nclient\n \n=\n \nawait\n \nlogin\n(\n\n        \n\"http://eucula.local:5240/MAAS/\"\n,\n\n        \nusername\n=\n\"gavin\"\n,\n \npassword\n=\n\"f00b4r\"\n)\n\n\n    \n# Get a reference to self.\n\n    \nmyself\n \n=\n \nawait\n \nclient\n.\nusers\n.\nwhoami\n()\n\n    \nassert\n \nmyself\n.\nis_admin\n,\n \n\"\n%s\n is not an admin\"\n \n%\n \nmyself\n.\nusername\n\n\n    \n# Check for a MAAS server capability.\n\n    \nversion\n \n=\n \nawait\n \nclient\n.\nversion\n.\nget\n()\n\n    \nassert\n \n\"devices-management\"\n \nin\n \nversion\n.\ncapabilities\n\n\n    \n# Check the default OS and distro series for deployments.\n\n    \nprint\n(\nawait\n \nclient\n.\nmaas\n.\nget_default_os\n())\n\n    \nprint\n(\nawait\n \nclient\n.\nmaas\n.\nget_default_distro_series\n())\n\n\n    \n# Set the HTTP proxy.\n\n    \nawait\n \nclient\n.\nmaas\n.\nset_http_proxy\n(\n\"http://localhost:3128\"\n)\n\n\n    \n# Allocate and deploy a machine.\n\n    \nmachine\n \n=\n \nawait\n \nclient\n.\nmachines\n.\nallocate\n()\n\n    \nawait\n \nmachine\n.\ndeploy\n()\n\n\n\nwork_with_maas\n()",
            "title": "Home"
        },
        {
            "location": "/client/index.html#the-web-api-client",
            "text": "Calling  maas.client.login  or  maas.client.connect  will return a maas.client.facade.Client  instance. This provides an easy to\nunderstand starting point for working with MAAS\u2019s Web API.",
            "title": "The Web API client"
        },
        {
            "location": "/client/index.html#an-example",
            "text": "#!/usr/bin/env python3.5  from   maas.client   import   login  client   =   login ( \n     \"http://localhost:5240/MAAS/\" , \n     username = \"foo\" ,   password = \"bar\" ,  )  # Get a reference to self.  myself   =   client . users . whoami ()  assert   myself . is_admin ,   \" %s  is not an admin\"   %   myself . username  # Check for a MAAS server capability.  version   =   client . version . get ()  assert   \"devices-management\"   in   version . capabilities  # Check the default OS and distro series for deployments.  print ( client . maas . get_default_os ())  print ( client . maas . get_default_distro_series ())  # Set the HTTP proxy.  client . maas . set_http_proxy ( \"http://localhost:3128\" )  # Allocate and deploy a machine.  machine   =   client . machines . allocate ()  machine . deploy ()",
            "title": "An example"
        },
        {
            "location": "/client/index.html#again-but-asynchronous",
            "text": "At first glance  python-libmaas  appears to be a blocking API, but it\u2019s\nactually asynchronous under the skin, based on  asyncio . If you call\ninto  python-libmaas  from within a running event loop it will behave\nasynchronously, but called from outside it behaves synchronously, and\nblocks.  Using  python-libmaas  interactively, when exploring the library or\ntrying something out, is familiar and natural because it behaves as a\nsynchronous, blocking API. This mode can be used of in scripts too, but\nthe same code can be easily repurposed for use in an asynchronous,\nnon-blocking application.  Below shows the earlier example but implemented in an asynchronous\nstyle. Note the use of the  asynchronous  decorator: this is used\nheavily in  python-libmaas  \u2014 along with the  Asynchronous  metaclass\n\u2014 to create the automatic blocking/not-blocking behaviour.  #!/usr/bin/env python3.5  from   maas.client   import   login  from   maas.client.utils.async   import   asynchronous  @asynchronous  async   def   work_with_maas (): \n     client   =   await   login ( \n         \"http://eucula.local:5240/MAAS/\" , \n         username = \"gavin\" ,   password = \"f00b4r\" ) \n\n     # Get a reference to self. \n     myself   =   await   client . users . whoami () \n     assert   myself . is_admin ,   \" %s  is not an admin\"   %   myself . username \n\n     # Check for a MAAS server capability. \n     version   =   await   client . version . get () \n     assert   \"devices-management\"   in   version . capabilities \n\n     # Check the default OS and distro series for deployments. \n     print ( await   client . maas . get_default_os ()) \n     print ( await   client . maas . get_default_distro_series ()) \n\n     # Set the HTTP proxy. \n     await   client . maas . set_http_proxy ( \"http://localhost:3128\" ) \n\n     # Allocate and deploy a machine. \n     machine   =   await   client . machines . allocate () \n     await   machine . deploy ()  work_with_maas ()",
            "title": "Again, but asynchronous"
        },
        {
            "location": "/bones/index.html",
            "text": "Bones\n: Low-level Python client API\n\n\nYou may prefer the \nhigher-level API \nviscera\n,\nbut maybe you need to do something that you can\u2019t do in \nviscera\n yet\n(please file a bug!), or you\u2019re developing \nviscera\n itself (which uses\n\nbones\n behind the scenes).\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\n\n\nfrom\n \nhttp\n \nimport\n \nHTTPStatus\n\n\nfrom\n \npprint\n \nimport\n \npprint\n\n\nfrom\n \nmaas.client\n \nimport\n \nbones\n\n\n\nprofile\n,\n \nsession\n \n=\n \nbones\n.\nSessionAPI\n.\nlogin\n(\n\n    \n\"http://localhost:5240/MAAS/\"\n,\n \nusername\n=\n\"alice\"\n,\n\n    \npassword\n=\n\"wonderland\"\n)\n\n\n\n# Create a tag if it doesn't exist.\n\n\ntag_name\n \n=\n \n\"gryphon\"\n\n\ntag_comment\n \n=\n \n\"Gryphon's Stuff\"\n\n\ntry\n:\n\n    \ntag\n \n=\n \nsession\n.\nTag\n.\nread\n(\nname\n=\ntag_name\n)\n\n\nexcept\n \nbones\n.\nCallError\n \nas\n \nerror\n:\n\n    \nif\n \nerror\n.\nstatus\n \n==\n \nHTTPStatus\n.\nNOT_FOUND\n:\n\n        \ntag\n \n=\n \nsession\n.\nTags\n.\nnew\n(\n\n            \nname\n=\ntag_name\n,\n \ncomment\n=\ntag_comment\n)\n\n    \nelse\n:\n\n        \nraise\n\n\n\n# List all the tags.\n\n\nprint\n(\n\">>> Tags.list()\"\n)\n\n\npprint\n(\nsession\n.\nTags\n.\nlist\n())\n\n\n\n# Get the system IDs for all nodes.\n\n\nprint\n(\n\">>> Nodes.list()\"\n)\n\n\nall_nodes_system_ids\n \n=\n \n[\n\n    \nnode\n[\n\"system_id\"\n]\n \nfor\n \nnode\n \nin\n \nsession\n.\nNodes\n.\nlist\n()\n\n\n]\n\n\npprint\n(\nall_nodes_system_ids\n)\n\n\n\n# Associate the tag with all nodes.\n\n\nprint\n(\n\">>> Tag.update_nodes()\"\n)\n\n\npprint\n(\nsession\n.\nTag\n.\nupdate_nodes\n(\n\n    \nname\n=\ntag\n[\n\"name\"\n],\n \nadd\n=\nall_nodes_system_ids\n))",
            "title": "Home"
        },
        {
            "location": "/bones/index.html#bones-low-level-python-client-api",
            "text": "You may prefer the  higher-level API  viscera ,\nbut maybe you need to do something that you can\u2019t do in  viscera  yet\n(please file a bug!), or you\u2019re developing  viscera  itself (which uses bones  behind the scenes).",
            "title": "Bones: Low-level Python client API"
        },
        {
            "location": "/bones/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5  from   http   import   HTTPStatus  from   pprint   import   pprint  from   maas.client   import   bones  profile ,   session   =   bones . SessionAPI . login ( \n     \"http://localhost:5240/MAAS/\" ,   username = \"alice\" , \n     password = \"wonderland\" )  # Create a tag if it doesn't exist.  tag_name   =   \"gryphon\"  tag_comment   =   \"Gryphon's Stuff\"  try : \n     tag   =   session . Tag . read ( name = tag_name )  except   bones . CallError   as   error : \n     if   error . status   ==   HTTPStatus . NOT_FOUND : \n         tag   =   session . Tags . new ( \n             name = tag_name ,   comment = tag_comment ) \n     else : \n         raise  # List all the tags.  print ( \">>> Tags.list()\" )  pprint ( session . Tags . list ())  # Get the system IDs for all nodes.  print ( \">>> Nodes.list()\" )  all_nodes_system_ids   =   [ \n     node [ \"system_id\" ]   for   node   in   session . Nodes . list ()  ]  pprint ( all_nodes_system_ids )  # Associate the tag with all nodes.  print ( \">>> Tag.update_nodes()\" )  pprint ( session . Tag . update_nodes ( \n     name = tag [ \"name\" ],   add = all_nodes_system_ids ))",
            "title": "Some example code"
        },
        {
            "location": "/viscera/index.html",
            "text": "Viscera\n: High-level Python client API\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\n\n\nfrom\n \npprint\n \nimport\n \npprint\n\n\nfrom\n \nmaas.client\n \nimport\n \nviscera\n\n\n\nprofile\n,\n \norigin\n \n=\n \nviscera\n.\nOrigin\n.\nlogin\n(\n\n    \n\"http://localhost:5240/MAAS/\"\n,\n \nusername\n=\n\"alice\"\n,\n\n    \npassword\n=\n\"wonderland\"\n)\n\n\n\n# List all the tags.\n\n\nprint\n(\n\">>> origin.Tags.read()\"\n)\n\n\npprint\n(\norigin\n.\nTags\n.\nread\n())\n\n\n\n# List all machines.\n\n\nprint\n(\n\">>> origin.Machines.read()\"\n)\n\n\npprint\n(\norigin\n.\nMachines\n.\nread\n())",
            "title": "Home"
        },
        {
            "location": "/viscera/index.html#viscera-high-level-python-client-api",
            "text": "",
            "title": "Viscera: High-level Python client API"
        },
        {
            "location": "/viscera/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5  from   pprint   import   pprint  from   maas.client   import   viscera  profile ,   origin   =   viscera . Origin . login ( \n     \"http://localhost:5240/MAAS/\" ,   username = \"alice\" , \n     password = \"wonderland\" )  # List all the tags.  print ( \">>> origin.Tags.read()\" )  pprint ( origin . Tags . read ())  # List all machines.  print ( \">>> origin.Machines.read()\" )  pprint ( origin . Machines . read ())",
            "title": "Some example code"
        },
        {
            "location": "/viscera/getting-started/index.html",
            "text": "Getting started with \nviscera\n\n\nLogging-in\n\n\nLog-in using the command-line tool and start an interactive Python\nshell:\n\n\n$\n maas profiles login foo http://example.com:5240/MAAS/ admin\n\nPassword: \u2026\n\n\n$\n maas shell\n\n\n\n\n\nThis will provide you with a pre-prepared \norigin\n object that points to\n\nfoo\n from above. This is the root object of the API.\n\n\nYou can also log-in programmatically:\n\n\n>>> \nprofile\n,\n \norigin\n \n=\n \nOrigin\n.\nlogin\n(\n\n\n... \n    \n\"http://example.com:5240/MAAS/\"\n,\n \nusername\n=\n\"admin\"\n,\n\n\n... \n    \npassword\n=\n\"\u2026\"\n)\n\n\n\n\n\n\nThe \nprofile\n has not been saved, but it\u2019s easy to do so:\n\n\n>>> \nprofile\n \n=\n \nprofile\n.\nreplace\n(\nname\n=\n\"foo\"\n)\n\n\n>>> \nwith\n \nProfileStore\n.\nopen\n()\n \nas\n \nstore\n:\n\n\n... \n    \nstore\n.\nsave\n(\nprofile\n)\n\n\n... \n    \nstore\n.\ndefault\n \n=\n \nprofile\n\n\n\n\n\n\nThis does the same as the \nmaas profiles login\n command.\n\n\nBut there\u2019s no need! There\u2019s a command built in to do it for you:\n\n\n$\n bin/maas shell\n\nWelcome to the MAAS shell.\n\n\n\nPredefined variables:\n\n\n\n    origin: A `viscera` origin, configured for foo.\n\n\n   session: A `bones` session, configured for foo.\n\n\n\n>\n>>\n\n\n\n\n\nLogging-out\n\n\nLog-out using the command-line tool:\n\n\n$\n bin/maas profiles remove foo\n\n\n\n\n\nor, programmatically:\n\n\n>>> \nwith\n \nProfileStore\n.\nopen\n()\n \nas\n \nstore\n:\n\n\n... \n    \nstore\n.\ndelete\n(\n\"foo\"\n)\n\n\n\n\n\n\ndir()\n, \nhelp()\n, and tab-completion\n\n\nThe \nviscera\n API has been designed to be very discoverable using\ntab-completion, \ndir()\n, \nhelp()\n, and so on. Start with that:\n\n\n>>> \norigin\n.<\ntab\n>\n\n\n\u2026\n\n\n\n\n\n\nThis works best when you\u2019ve got \nIPython\n\ninstalled.",
            "title": "Getting started"
        },
        {
            "location": "/viscera/getting-started/index.html#getting-started-with-viscera",
            "text": "",
            "title": "Getting started with viscera"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-in",
            "text": "Log-in using the command-line tool and start an interactive Python\nshell:  $  maas profiles login foo http://example.com:5240/MAAS/ admin Password: \u2026  $  maas shell  This will provide you with a pre-prepared  origin  object that points to foo  from above. This is the root object of the API.  You can also log-in programmatically:  >>>  profile ,   origin   =   Origin . login (  ...       \"http://example.com:5240/MAAS/\" ,   username = \"admin\" ,  ...       password = \"\u2026\" )   The  profile  has not been saved, but it\u2019s easy to do so:  >>>  profile   =   profile . replace ( name = \"foo\" )  >>>  with   ProfileStore . open ()   as   store :  ...       store . save ( profile )  ...       store . default   =   profile   This does the same as the  maas profiles login  command.  But there\u2019s no need! There\u2019s a command built in to do it for you:  $  bin/maas shell Welcome to the MAAS shell.  Predefined variables:      origin: A `viscera` origin, configured for foo.     session: A `bones` session, configured for foo.  > >>",
            "title": "Logging-in"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-out",
            "text": "Log-out using the command-line tool:  $  bin/maas profiles remove foo  or, programmatically:  >>>  with   ProfileStore . open ()   as   store :  ...       store . delete ( \"foo\" )",
            "title": "Logging-out"
        },
        {
            "location": "/viscera/getting-started/index.html#dir-help-and-tab-completion",
            "text": "The  viscera  API has been designed to be very discoverable using\ntab-completion,  dir() ,  help() , and so on. Start with that:  >>>  origin .< tab >  \u2026   This works best when you\u2019ve got  IPython \ninstalled.",
            "title": "dir(), help(), and tab-completion"
        },
        {
            "location": "/viscera/nodes/index.html",
            "text": "Viscera\n: Working with machines, devices, racks, and regions\n\n\nGiven an \nOrigin\n instance bound to your MAAS server, you can\ninterrogate your nodes with:\n\n\norigin\n.\nMachines\n.\nread\n()\n\n  \n# returns an origin.Machines instance, a\n\n  \n# sequence of origin.Machine instances.\n\n\n\norigin\n.\nDevices\n.\nread\n()\n\n  \n# returns an origin.Devices instance, a\n\n  \n# sequence of origin.Device instances.\n\n\n\norigin\n.\nRackControllers\n.\nread\n()\n\n  \n# returns an origin.RackControllers instance, a\n\n  \n# sequence of origin.RackController instances.\n\n\n\norigin\n.\nRegionControllers\n.\nread\n()\n\n  \n# returns an origin.RegionControllers instance, a\n\n  \n# sequence of origin.RegionController instances.\n\n\n\n\n\n\nAn example\n\n\n>>> \nfor\n \nmachine\n \nin\n \norigin\n.\nMachines\n.\nread\n():\n\n\n... \n    \nprint\n(\nrepr\n(\nnode\n))\n\n\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\n\n\nIndividual nodes can be read from the Web API.\n\n\n>>> \nmachine\n \n=\n \norigin\n.\nMachine\n.\nread\n(\nsystem_id\n=\n\"pncys4\"\n)\n\n\n>>> \nmachine\n\n\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\n\n\nMachines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:\n\n\n>>> \nmachine\n.\narchitecture\n\n\n'amd64/generic'\n\n\n>>> \nmachine\n.\ncpus\n\n\n4\n\n\n\n\n\n\nDon\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or\n\ndir(machine)\n to find out what other fields and methods are\navailable.\n\n\nTODO\n: Updating nodes.\n\n\nAllocating and deploying\n\n\n>>> \nhelp\n(\norigin\n.\nMachines\n.\nallocate\n)\n\n\nHelp on method allocate in module maas.client.viscera.machines:\n\n\n\nallocate(\n\n\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n\n\n    memory:float=None, tags:typing.Sequence=None)\n\n\n  method of maas.client.viscera.machines.MachinesType instance\n\n\n    :param hostname: The hostname to match.\n\n\n    :param architecture: The architecture to match, e.g. \"amd64\".\n\n\n    :param cpus: The minimum number of CPUs to match.\n\n\n    :param memory: The minimum amount of RAM to match.\n\n\n    :param tags: The tags to match, as a sequence. Each tag may be\n\n\n        prefixed with a hyphen to denote that the given tag should NOT be\n\n\n        associated with a matched machine.\n\n\n>>> \nmachine\n \n=\n \norigin\n.\nMachines\n.\nallocate\n(\ntags\n=\n(\n\"foo\"\n,\n \n\"-bar\"\n))\n\n\n>>> \nprint\n(\nmachine\n.\nstatus_name\n)\n\n\nAcquired\n\n\n>>> \nmachine\n.\ndeploy\n()\n\n\n>>> \nprint\n(\nmachine\n.\nstatus_name\n)\n\n\nDeploying",
            "title": "Nodes"
        },
        {
            "location": "/viscera/nodes/index.html#viscera-working-with-machines-devices-racks-and-regions",
            "text": "Given an  Origin  instance bound to your MAAS server, you can\ninterrogate your nodes with:  origin . Machines . read () \n   # returns an origin.Machines instance, a \n   # sequence of origin.Machine instances.  origin . Devices . read () \n   # returns an origin.Devices instance, a \n   # sequence of origin.Device instances.  origin . RackControllers . read () \n   # returns an origin.RackControllers instance, a \n   # sequence of origin.RackController instances.  origin . RegionControllers . read () \n   # returns an origin.RegionControllers instance, a \n   # sequence of origin.RegionController instances.",
            "title": "Viscera: Working with machines, devices, racks, and regions"
        },
        {
            "location": "/viscera/nodes/index.html#an-example",
            "text": ">>>  for   machine   in   origin . Machines . read ():  ...       print ( repr ( node ))  <Machine hostname='botswana' system_id='pncys4'>   Individual nodes can be read from the Web API.  >>>  machine   =   origin . Machine . read ( system_id = \"pncys4\" )  >>>  machine  <Machine hostname='botswana' system_id='pncys4'>   Machines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:  >>>  machine . architecture  'amd64/generic'  >>>  machine . cpus  4   Don\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or dir(machine)  to find out what other fields and methods are\navailable.  TODO : Updating nodes.",
            "title": "An example"
        },
        {
            "location": "/viscera/nodes/index.html#allocating-and-deploying",
            "text": ">>>  help ( origin . Machines . allocate )  Help on method allocate in module maas.client.viscera.machines:  allocate(      *, hostname:str=None, architecture:str=None, cpus:int=None,      memory:float=None, tags:typing.Sequence=None)    method of maas.client.viscera.machines.MachinesType instance      :param hostname: The hostname to match.      :param architecture: The architecture to match, e.g. \"amd64\".      :param cpus: The minimum number of CPUs to match.      :param memory: The minimum amount of RAM to match.      :param tags: The tags to match, as a sequence. Each tag may be          prefixed with a hyphen to denote that the given tag should NOT be          associated with a matched machine.  >>>  machine   =   origin . Machines . allocate ( tags = ( \"foo\" ,   \"-bar\" ))  >>>  print ( machine . status_name )  Acquired  >>>  machine . deploy ()  >>>  print ( machine . status_name )  Deploying",
            "title": "Allocating and deploying"
        },
        {
            "location": "/viscera/events/index.html",
            "text": "Events\n\n\nEvents are similar\u2026 but different. The only way to get events is by\nthe \nquery\n method:\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n()\n\n\n\n\n\n\nThis accepts a plethora of optional arguments to narrow down the results:\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nhostnames\n=\n{\n\"foo\"\n,\n \n\"bar\"\n})\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\ndomains\n=\n{\n\"example.com\"\n,\n \n\"maas.io\"\n})\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nzones\n=\n[\n\"red\"\n,\n \n\"blue\"\n])\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nmacs\n=\n(\n\"12:34:56:78:90:ab\"\n,\n \n))\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nsystem_ids\n=\n\u2026\n)\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nagent_name\n=\n\u2026\n)\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nlevel\n=\n\u2026\n)\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nafter\n=\n\u2026\n,\n \nlimit\n=\n\u2026\n)\n\n\n\n\n\n\nThese arguments can be combined to narrow the results even further.\n\n\nThe \nlevel\n argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are defined in the\n\nLevel\n enum:\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nlevel\n=\norigin\n.\nEvents\n.\nLevel\n.\nERROR\n)\n\n\n\n\n\n\nbut you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/viscera/events/index.html#events",
            "text": "Events are similar\u2026 but different. The only way to get events is by\nthe  query  method:  >>>  events   =   origin . Events . query ()   This accepts a plethora of optional arguments to narrow down the results:  >>>  events   =   origin . Events . query ( hostnames = { \"foo\" ,   \"bar\" })  >>>  events   =   origin . Events . query ( domains = { \"example.com\" ,   \"maas.io\" })  >>>  events   =   origin . Events . query ( zones = [ \"red\" ,   \"blue\" ])  >>>  events   =   origin . Events . query ( macs = ( \"12:34:56:78:90:ab\" ,   ))  >>>  events   =   origin . Events . query ( system_ids = \u2026 )  >>>  events   =   origin . Events . query ( agent_name = \u2026 )  >>>  events   =   origin . Events . query ( level = \u2026 )  >>>  events   =   origin . Events . query ( after = \u2026 ,   limit = \u2026 )   These arguments can be combined to narrow the results even further.  The  level  argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are defined in the Level  enum:  >>>  events   =   origin . Events . query ( level = origin . Events . Level . ERROR )   but you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/viscera/other/index.html",
            "text": "Other objects\n\n\nFiles, users, tags\n\n\nSimilarly to nodes, these sets of objects can be fetched:\n\n\n>>> \ntags\n \n=\n \norigin\n.\nTags\n.\nread\n()\n\n\n>>> \nfiles\n \n=\n \norigin\n.\nFiles\n.\nread\n()\n\n\n>>> \nusers\n \n=\n \norigin\n.\nUsers\n.\nread\n()\n\n\n\n\n\n\nWhen reading from collections, as above, the returned object is\nlist-like:\n\n\n>>> \nlen\n(\ntags\n)\n\n\n5\n\n\n>>> \ntags\n[\n3\n]\n\n\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n\n\n>>> \ntags\n[\n3\n]\n \nin\n \ntags\n\n\nTrue\n\n\n>>> \nnot_foo\n \n=\n \n[\ntag\n \nfor\n \ntag\n \nin\n \ntags\n \nif\n \ntag\n.\nname\n \n!=\n \n'foo'\n]\n\n\n>>> \nlen\n(\nnot_foo\n)\n\n\n4\n\n\n\n\n\n\nHowever, it\u2019s read-only:\n\n\n>>> \ntags\n[\n0\n]\n \n=\n \n\"bob\"\n\n\n\u2026\n\n\nTypeError: 'Tags' object does not support item assignment",
            "title": "Other objects"
        },
        {
            "location": "/viscera/other/index.html#other-objects",
            "text": "",
            "title": "Other objects"
        },
        {
            "location": "/viscera/other/index.html#files-users-tags",
            "text": "Similarly to nodes, these sets of objects can be fetched:  >>>  tags   =   origin . Tags . read ()  >>>  files   =   origin . Files . read ()  >>>  users   =   origin . Users . read ()   When reading from collections, as above, the returned object is\nlist-like:  >>>  len ( tags )  5  >>>  tags [ 3 ]  <Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>  >>>  tags [ 3 ]   in   tags  True  >>>  not_foo   =   [ tag   for   tag   in   tags   if   tag . name   !=   'foo' ]  >>>  len ( not_foo )  4   However, it\u2019s read-only:  >>>  tags [ 0 ]   =   \"bob\"  \u2026  TypeError: 'Tags' object does not support item assignment",
            "title": "Files, users, tags"
        }
    ]
}