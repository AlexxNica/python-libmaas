{
    "docs": [
        {
            "location": "/index.html",
            "text": "Welcome to MAAS's new command-line tool & Python client library\n\n\n\npython-libmaas\n provides:\n\n\n\n\n\n\nA rich and stable Python client library for interacting with MAAS 2.0+\n  servers. This can be used in a synchronous/blocking mode, or an\n  asynchronous/non-blocking mode based on \nasyncio\n.\n\n\n\n\n\n\nA lower-level Python client library, auto-generated to match the MAAS\n  server it\u2019s interacting with.\n\n\n\n\n\n\nA command-line tool for working with MAAS servers.\n\n\n\n\n\n\nFor MAAS \nserver\n documentation, visit\n\ndocs.ubuntu.com\n.\n\n\n\n\nThis is \nALPHA\n software. We are converging on a finished product, but\nuntil we release a beta all APIs could change.\n\n\n\n\nInstallation\n\n\nEither work from a branch:\n\n\n$ git clone https://github.com/maas/python-libmaas.git\n$ cd python-libmaas\n$ make\n\n\n\n\nOr install with \npip\n into a\n\nvirtualenv\n:\n\n\n$ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install git+https://github.com/maas/python-libmaas.git\n\n\n\n\nOr install from \nPyPI\n:\n\n\n$ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install python-libmaas\n\n\n\n\nNote\n that PyPI may lag the others.\n\n\nThis documentation assumes you\u2019re working from a branch or in a\nvirtualenv. In practice this means it will use partially qualified paths\nlike \nbin/maas\n instead of bare \nmaas\n invocations. If you\u2019ve\ninstalled from PyPI the \nmaas\n command will probably be installed on\nyour shell\u2019s \nPATH\n so you can invoke it as \nmaas\n.\n\n\nCommand-line\n\n\n$ bin/maas profiles login --help\n$ bin/maas profiles login exmpl \\\n>   http://example.com:5240/MAAS/ my_username\nPassword: \u2026\n$ bin/maas list\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u2502 Hostname   \u2502 System ID \u2502 #CPUs \u2502 RAM    \u2502 Status \u2502 Power   \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 m \u2502 botswana   \u2502 pncys4    \u2502 4     \u2502 8.0 GB \u2502 Ready  \u2502 Off     \u2502\n\u2502 c \u2502 namibia    \u2502 xfaxgw    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Error   \u2502\n\u2502 C \u2502 madagascar \u2502 4y3h7n    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Unknown \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n\n\nClient library\n\n\nFor a developer the simplest entry points into \npython-libmaas\n are\nthe \nconnect\n and \nlogin\n functions in \nmaas.client\n. The former\nconnects to a MAAS server using a previously obtained API key, and the\nlatter logs-in to MAAS with your username and password. These returns a\n\nClient\n object that has convenient attributes for working with MAAS.\n\n\nFor example, this prints out a few recent events:\n\n\nfrom maas.client import login\nclient = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"my_user\", password=\"my_pass\",\n)\ntmpl = (\n    \"{0.created:%Y-%m-%d %H:%M:%S} \"\n    \"{0.level.name} {0.description_short}\"\n)\nfor event in client.events.query():\n    print(tmpl.format(event))\n\n\n\n\nLearn more about the \nclient\n.\n\n\nShell\n\n\nThere\u2019s an interactive shell too. This imports some convenient bits into\nthe default namespace, and creates a \nviscera\n \nOrigin\n instance and a\n\nbones\n \nSessionAPI\n instance bound to the currently selected profile.\n\n\nFor the best experience install \nIPython\n first.\n\n\n$ bin/maas shell\nWelcome to the MAAS shell.\n...\n\n\n\n\n>>> origin.Version.read()\n<Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]>\n\n\n\n\nDevelopment\n\n\nIt\u2019s easy to start hacking on \npython-libmaas\n:\n\n\n$ git clone git@github.com:maas/python-libmaas.git\n$ cd python-libmaas\n$ make develop\n$ make test\n\n\n\n\nInstalling \nIPython\n is generally a good idea too:\n\n\n$ bin/pip install -UI IPython\n\n\n\n\nPull requests are welcome but authors need to sign the \nCanonical\ncontributor license agreement\n before those PRs can be merged.\n\n\nbones\n & \nviscera\n\n\nDigging around in the code and when using the primary client API, you\nmay find references to \nbones\n and \nviscera\n. These libraries form the\nbase for the client API:\n\n\n\n\n\n\nbones\n is a lower-level library that closely\n  mirrors MAAS\u2019s Web API. Every MAAS server publishes a description of\n  its Web API and \nbones\n generates a convenient mechanism to interact\n  with it.\n\n\n\n\n\n\nviscera\n is a higher-level library which makes\n  heavy use of \nbones\n. MAAS\u2019s Web API is sometimes unfriendly or\n  inconsistent, but \nviscera\n presents a hand-crafted API that has been\n  designed for developers rather than machines.",
            "title": "Home"
        },
        {
            "location": "/index.html#installation",
            "text": "Either work from a branch:  $ git clone https://github.com/maas/python-libmaas.git\n$ cd python-libmaas\n$ make  Or install with  pip  into a virtualenv :  $ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install git+https://github.com/maas/python-libmaas.git  Or install from  PyPI :  $ virtualenv --python=python3.5 amc && source amc/bin/activate\n$ pip install python-libmaas  Note  that PyPI may lag the others.  This documentation assumes you\u2019re working from a branch or in a\nvirtualenv. In practice this means it will use partially qualified paths\nlike  bin/maas  instead of bare  maas  invocations. If you\u2019ve\ninstalled from PyPI the  maas  command will probably be installed on\nyour shell\u2019s  PATH  so you can invoke it as  maas .",
            "title": "Installation"
        },
        {
            "location": "/index.html#command-line",
            "text": "$ bin/maas profiles login --help\n$ bin/maas profiles login exmpl \\\n>   http://example.com:5240/MAAS/ my_username\nPassword: \u2026\n$ bin/maas list\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   \u2502 Hostname   \u2502 System ID \u2502 #CPUs \u2502 RAM    \u2502 Status \u2502 Power   \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 m \u2502 botswana   \u2502 pncys4    \u2502 4     \u2502 8.0 GB \u2502 Ready  \u2502 Off     \u2502\n\u2502 c \u2502 namibia    \u2502 xfaxgw    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Error   \u2502\n\u2502 C \u2502 madagascar \u2502 4y3h7n    \u2502 4     \u2502 8.0 GB \u2502 \u2014      \u2502 Unknown \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
            "title": "Command-line"
        },
        {
            "location": "/index.html#client-library",
            "text": "For a developer the simplest entry points into  python-libmaas  are\nthe  connect  and  login  functions in  maas.client . The former\nconnects to a MAAS server using a previously obtained API key, and the\nlatter logs-in to MAAS with your username and password. These returns a Client  object that has convenient attributes for working with MAAS.  For example, this prints out a few recent events:  from maas.client import login\nclient = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"my_user\", password=\"my_pass\",\n)\ntmpl = (\n    \"{0.created:%Y-%m-%d %H:%M:%S} \"\n    \"{0.level.name} {0.description_short}\"\n)\nfor event in client.events.query():\n    print(tmpl.format(event))  Learn more about the  client .",
            "title": "Client library"
        },
        {
            "location": "/index.html#shell",
            "text": "There\u2019s an interactive shell too. This imports some convenient bits into\nthe default namespace, and creates a  viscera   Origin  instance and a bones   SessionAPI  instance bound to the currently selected profile.  For the best experience install  IPython  first.  $ bin/maas shell\nWelcome to the MAAS shell.\n...  >>> origin.Version.read()\n<Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]>",
            "title": "Shell"
        },
        {
            "location": "/index.html#development",
            "text": "It\u2019s easy to start hacking on  python-libmaas :  $ git clone git@github.com:maas/python-libmaas.git\n$ cd python-libmaas\n$ make develop\n$ make test  Installing  IPython  is generally a good idea too:  $ bin/pip install -UI IPython  Pull requests are welcome but authors need to sign the  Canonical\ncontributor license agreement  before those PRs can be merged.",
            "title": "Development"
        },
        {
            "location": "/index.html#bones-viscera",
            "text": "Digging around in the code and when using the primary client API, you\nmay find references to  bones  and  viscera . These libraries form the\nbase for the client API:    bones  is a lower-level library that closely\n  mirrors MAAS\u2019s Web API. Every MAAS server publishes a description of\n  its Web API and  bones  generates a convenient mechanism to interact\n  with it.    viscera  is a higher-level library which makes\n  heavy use of  bones . MAAS\u2019s Web API is sometimes unfriendly or\n  inconsistent, but  viscera  presents a hand-crafted API that has been\n  designed for developers rather than machines.",
            "title": "bones &amp; viscera"
        },
        {
            "location": "/client/index.html",
            "text": "The Web API client\n\n\n\nCalling \nmaas.client.login\n or \nmaas.client.connect\n will return a\n\nmaas.client.facade.Client\n instance. This provides an easy to\nunderstand starting point for working with MAAS\u2019s Web API.\n\n\nAn example\n\n\n#!/usr/bin/env python3.5\n\nfrom maas.client import login\n\nclient = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"foo\", password=\"bar\",\n)\n\n# Get a reference to self.\nmyself = client.users.whoami()\nassert myself.is_admin, \"%s is not an admin\" % myself.username\n\n# Check for a MAAS server capability.\nversion = client.version.get()\nassert \"devices-management\" in version.capabilities\n\n# Check the default OS and distro series for deployments.\nprint(client.maas.get_default_os())\nprint(client.maas.get_default_distro_series())\n\n# Set the HTTP proxy.\nclient.maas.set_http_proxy(\"http://localhost:3128\")\n\n# Allocate and deploy a machine.\nmachine = client.machines.allocate()\nmachine.deploy()\n\n\n\n\nAgain, but asynchronous\n\n\nAt first glance \npython-libmaas\n appears to be a blocking API, but it\u2019s\nactually asynchronous under the skin, based on \nasyncio\n. If you call\ninto \npython-libmaas\n from within a running event loop it will behave\nasynchronously, but called from outside it behaves synchronously, and\nblocks.\n\n\nUsing \npython-libmaas\n interactively, when exploring the library or\ntrying something out, is familiar and natural because it behaves as a\nsynchronous, blocking API. This mode can be used of in scripts too, but\nthe same code can be easily repurposed for use in an asynchronous,\nnon-blocking application.\n\n\nBelow shows the earlier example but implemented in an asynchronous\nstyle. Note the use of the \nasynchronous\n decorator: this is used\nheavily in \npython-libmaas\n \u2014 along with the \nAsynchronous\n metaclass\n\u2014 to create the automatic blocking/not-blocking behaviour.\n\n\n#!/usr/bin/env python3.5\n\nfrom maas.client import login\nfrom maas.client.utils.async import asynchronous\n\n@asynchronous\nasync def work_with_maas():\n    client = await login(\n        \"http://eucula.local:5240/MAAS/\",\n        username=\"gavin\", password=\"f00b4r\")\n\n    # Get a reference to self.\n    myself = await client.users.whoami()\n    assert myself.is_admin, \"%s is not an admin\" % myself.username\n\n    # Check for a MAAS server capability.\n    version = await client.version.get()\n    assert \"devices-management\" in version.capabilities\n\n    # Check the default OS and distro series for deployments.\n    print(await client.maas.get_default_os())\n    print(await client.maas.get_default_distro_series())\n\n    # Set the HTTP proxy.\n    await client.maas.set_http_proxy(\"http://localhost:3128\")\n\n    # Allocate and deploy a machine.\n    machine = await client.machines.allocate()\n    await machine.deploy()\n\nwork_with_maas()",
            "title": "Introduction"
        },
        {
            "location": "/client/index.html#an-example",
            "text": "#!/usr/bin/env python3.5\n\nfrom maas.client import login\n\nclient = login(\n    \"http://localhost:5240/MAAS/\",\n    username=\"foo\", password=\"bar\",\n)\n\n# Get a reference to self.\nmyself = client.users.whoami()\nassert myself.is_admin, \"%s is not an admin\" % myself.username\n\n# Check for a MAAS server capability.\nversion = client.version.get()\nassert \"devices-management\" in version.capabilities\n\n# Check the default OS and distro series for deployments.\nprint(client.maas.get_default_os())\nprint(client.maas.get_default_distro_series())\n\n# Set the HTTP proxy.\nclient.maas.set_http_proxy(\"http://localhost:3128\")\n\n# Allocate and deploy a machine.\nmachine = client.machines.allocate()\nmachine.deploy()",
            "title": "An example"
        },
        {
            "location": "/client/index.html#again-but-asynchronous",
            "text": "At first glance  python-libmaas  appears to be a blocking API, but it\u2019s\nactually asynchronous under the skin, based on  asyncio . If you call\ninto  python-libmaas  from within a running event loop it will behave\nasynchronously, but called from outside it behaves synchronously, and\nblocks.  Using  python-libmaas  interactively, when exploring the library or\ntrying something out, is familiar and natural because it behaves as a\nsynchronous, blocking API. This mode can be used of in scripts too, but\nthe same code can be easily repurposed for use in an asynchronous,\nnon-blocking application.  Below shows the earlier example but implemented in an asynchronous\nstyle. Note the use of the  asynchronous  decorator: this is used\nheavily in  python-libmaas  \u2014 along with the  Asynchronous  metaclass\n\u2014 to create the automatic blocking/not-blocking behaviour.  #!/usr/bin/env python3.5\n\nfrom maas.client import login\nfrom maas.client.utils.async import asynchronous\n\n@asynchronous\nasync def work_with_maas():\n    client = await login(\n        \"http://eucula.local:5240/MAAS/\",\n        username=\"gavin\", password=\"f00b4r\")\n\n    # Get a reference to self.\n    myself = await client.users.whoami()\n    assert myself.is_admin, \"%s is not an admin\" % myself.username\n\n    # Check for a MAAS server capability.\n    version = await client.version.get()\n    assert \"devices-management\" in version.capabilities\n\n    # Check the default OS and distro series for deployments.\n    print(await client.maas.get_default_os())\n    print(await client.maas.get_default_distro_series())\n\n    # Set the HTTP proxy.\n    await client.maas.set_http_proxy(\"http://localhost:3128\")\n\n    # Allocate and deploy a machine.\n    machine = await client.machines.allocate()\n    await machine.deploy()\n\nwork_with_maas()",
            "title": "Again, but asynchronous"
        },
        {
            "location": "/client/nodes/index.html",
            "text": "Machines, devices, racks, and regions\n\n\n\nGiven a \nClient\n instance bound to your MAAS server, you can\ninterrogate your nodes with:\n\n\nclient.machines.list()\nclient.devices.list()\nclient.rack_controllers.list()\nclient.region_controllers.list()\n\n\n\n\nSome examples\n\n\n>>> for machine in client.machines.read():\n...     print(repr(node))\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nIndividual nodes can be read from the Web API.\n\n\n>>> machine = client.machines.get(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nMachines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:\n\n\n>>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4\n\n\n\n\nDon\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or\n\ndir(machine)\n to find out what other fields and methods are\navailable.\n\n\nTODO\n: Updating nodes.\n\n\nAllocating and deploying\n\n\n>>> help(client.machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = client.machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status_name)\nAcquired\n>>> machine.deploy()\n>>> print(machine.status_name)\nDeploying",
            "title": "Machines, devices, racks, and regions"
        },
        {
            "location": "/client/nodes/index.html#some-examples",
            "text": ">>> for machine in client.machines.read():\n...     print(repr(node))\n<Machine hostname='botswana' system_id='pncys4'>  Individual nodes can be read from the Web API.  >>> machine = client.machines.get(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>  Machines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:  >>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4  Don\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or dir(machine)  to find out what other fields and methods are\navailable.  TODO : Updating nodes.",
            "title": "Some examples"
        },
        {
            "location": "/client/nodes/index.html#allocating-and-deploying",
            "text": ">>> help(client.machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = client.machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status_name)\nAcquired\n>>> machine.deploy()\n>>> print(machine.status_name)\nDeploying",
            "title": "Allocating and deploying"
        },
        {
            "location": "/client/events/index.html",
            "text": "Events\n\n\n\nEvents are similar to other client objects\u2026 but a little different\ntoo. The only way to get events is by the \nquery\n method:\n\n\n>>> events = client.events.query()\n\n\n\n\nThis accepts a plethora of optional arguments to narrow down the results:\n\n\n>>> events = client.events.query(hostnames={\"foo\", \"bar\"})\n>>> events = client.events.query(domains={\"example.com\", \"maas.io\"})\n>>> events = client.events.query(zones=[\"red\", \"blue\"])\n>>> events = client.events.query(macs=(\"12:34:56:78:90:ab\", ))\n>>> events = client.events.query(system_ids=\u2026)\n>>> events = client.events.query(agent_name=\u2026)\n>>> events = client.events.query(level=\u2026)\n>>> events = client.events.query(after=\u2026, limit=\u2026)\n\n\n\n\nThese arguments can be combined to narrow the results even further.\n\n\nThe \nlevel\n argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are available in\n\nclient.events\n:\n\n\n>>> events = client.events.query(level=client.events.ERROR)\n\n\n\n\nbut you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/client/other/index.html",
            "text": "Other objects\n\n\n\nThere are several other object types available via the client API. Use\n\ndir()\n and tab-completion to dig around interactively, or read the\ncode; we\u2019ve tried to keep it readable.\n\n\nFiles, users, tags\n\n\nSimilarly to nodes, these sets of objects can be fetched:\n\n\n>>> tags = client.tags.list()\n>>> files = client.files.list()\n>>> users = client.users.list()\n\n\n\n\nWhen reading from collections, as above, the returned object is\nlist-like:\n\n\n>>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4\n\n\n\n\nHowever, it\u2019s read-only:\n\n\n>>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Others"
        },
        {
            "location": "/client/other/index.html#files-users-tags",
            "text": "Similarly to nodes, these sets of objects can be fetched:  >>> tags = client.tags.list()\n>>> files = client.files.list()\n>>> users = client.users.list()  When reading from collections, as above, the returned object is\nlist-like:  >>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4  However, it\u2019s read-only:  >>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Files, users, tags"
        },
        {
            "location": "/bones/index.html",
            "text": "bones\n \u2014 Low-level Python client API\n\n\n\nYou may prefer the \nhigher-level API \nviscera\n,\nbut maybe you need to do something that you can\u2019t do in \nviscera\n yet\n(please file a bug!), or you\u2019re developing \nviscera\n itself (which uses\n\nbones\n behind the scenes).\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\nfrom http import HTTPStatus\nfrom pprint import pprint\nfrom maas.client import bones\n\nprofile, session = bones.SessionAPI.login(\n    \"http://localhost:5240/MAAS/\", username=\"alice\",\n    password=\"wonderland\")\n\n# Create a tag if it doesn't exist.\ntag_name = \"gryphon\"\ntag_comment = \"Gryphon's Stuff\"\ntry:\n    tag = session.Tag.read(name=tag_name)\nexcept bones.CallError as error:\n    if error.status == HTTPStatus.NOT_FOUND:\n        tag = session.Tags.new(\n            name=tag_name, comment=tag_comment)\n    else:\n        raise\n\n# List all the tags.\nprint(\">>> Tags.list()\")\npprint(session.Tags.list())\n\n# Get the system IDs for all nodes.\nprint(\">>> Nodes.list()\")\nall_nodes_system_ids = [\n    node[\"system_id\"] for node in session.Nodes.list()\n]\npprint(all_nodes_system_ids)\n\n# Associate the tag with all nodes.\nprint(\">>> Tag.update_nodes()\")\npprint(session.Tag.update_nodes(\n    name=tag[\"name\"], add=all_nodes_system_ids))",
            "title": "Bones"
        },
        {
            "location": "/bones/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5\n\nfrom http import HTTPStatus\nfrom pprint import pprint\nfrom maas.client import bones\n\nprofile, session = bones.SessionAPI.login(\n    \"http://localhost:5240/MAAS/\", username=\"alice\",\n    password=\"wonderland\")\n\n# Create a tag if it doesn't exist.\ntag_name = \"gryphon\"\ntag_comment = \"Gryphon's Stuff\"\ntry:\n    tag = session.Tag.read(name=tag_name)\nexcept bones.CallError as error:\n    if error.status == HTTPStatus.NOT_FOUND:\n        tag = session.Tags.new(\n            name=tag_name, comment=tag_comment)\n    else:\n        raise\n\n# List all the tags.\nprint(\">>> Tags.list()\")\npprint(session.Tags.list())\n\n# Get the system IDs for all nodes.\nprint(\">>> Nodes.list()\")\nall_nodes_system_ids = [\n    node[\"system_id\"] for node in session.Nodes.list()\n]\npprint(all_nodes_system_ids)\n\n# Associate the tag with all nodes.\nprint(\">>> Tag.update_nodes()\")\npprint(session.Tag.update_nodes(\n    name=tag[\"name\"], add=all_nodes_system_ids))",
            "title": "Some example code"
        },
        {
            "location": "/viscera/index.html",
            "text": "viscera\n \u2014 High-level Python client API\n\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\nfrom pprint import pprint\nfrom maas.client import viscera\n\nprofile, origin = viscera.Origin.login(\n    \"http://localhost:5240/MAAS/\", username=\"alice\",\n    password=\"wonderland\")\n\n# List all the tags.\nprint(\">>> origin.Tags.read()\")\npprint(origin.Tags.read())\n\n# List all machines.\nprint(\">>> origin.Machines.read()\")\npprint(origin.Machines.read())",
            "title": "Introduction"
        },
        {
            "location": "/viscera/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5\n\nfrom pprint import pprint\nfrom maas.client import viscera\n\nprofile, origin = viscera.Origin.login(\n    \"http://localhost:5240/MAAS/\", username=\"alice\",\n    password=\"wonderland\")\n\n# List all the tags.\nprint(\">>> origin.Tags.read()\")\npprint(origin.Tags.read())\n\n# List all machines.\nprint(\">>> origin.Machines.read()\")\npprint(origin.Machines.read())",
            "title": "Some example code"
        },
        {
            "location": "/viscera/getting-started/index.html",
            "text": "Getting started with \nviscera\n\n\n\nLogging-in\n\n\nLog-in using the command-line tool and start an interactive Python\nshell:\n\n\n$ maas profiles login foo http://example.com:5240/MAAS/ admin\nPassword: \u2026\n$ maas shell\n\n\n\n\nThis will provide you with a pre-prepared \norigin\n object that points to\n\nfoo\n from above. This is the root object of the API.\n\n\nYou can also log-in programmatically:\n\n\n>>> profile, origin = Origin.login(\n...     \"http://example.com:5240/MAAS/\", username=\"admin\",\n...     password=\"\u2026\")\n\n\n\n\nThe \nprofile\n has not been saved, but it\u2019s easy to do so:\n\n\n>>> profile = profile.replace(name=\"foo\")\n>>> with ProfileStore.open() as store:\n...     store.save(profile)\n...     store.default = profile\n\n\n\n\nThis does the same as the \nmaas profiles login\n command.\n\n\nBut there\u2019s no need! There\u2019s a command built in to do it for you:\n\n\n$ bin/maas shell\nWelcome to the MAAS shell.\n\nPredefined variables:\n\n    origin: A `viscera` origin, configured for foo.\n   session: A `bones` session, configured for foo.\n\n>>>\n\n\n\n\nLogging-out\n\n\nLog-out using the command-line tool:\n\n\n$ bin/maas profiles remove foo\n\n\n\n\nor, programmatically:\n\n\n>>> with ProfileStore.open() as store:\n...     store.delete(\"foo\")\n\n\n\n\ndir()\n, \nhelp()\n, and tab-completion\n\n\nThe \nviscera\n API has been designed to be very discoverable using\ntab-completion, \ndir()\n, \nhelp()\n, and so on. Start with that:\n\n\n>>> origin.<tab>\n\u2026\n\n\n\n\nThis works best when you\u2019ve got \nIPython\n\ninstalled.",
            "title": "Getting started"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-in",
            "text": "Log-in using the command-line tool and start an interactive Python\nshell:  $ maas profiles login foo http://example.com:5240/MAAS/ admin\nPassword: \u2026\n$ maas shell  This will provide you with a pre-prepared  origin  object that points to foo  from above. This is the root object of the API.  You can also log-in programmatically:  >>> profile, origin = Origin.login(\n...     \"http://example.com:5240/MAAS/\", username=\"admin\",\n...     password=\"\u2026\")  The  profile  has not been saved, but it\u2019s easy to do so:  >>> profile = profile.replace(name=\"foo\")\n>>> with ProfileStore.open() as store:\n...     store.save(profile)\n...     store.default = profile  This does the same as the  maas profiles login  command.  But there\u2019s no need! There\u2019s a command built in to do it for you:  $ bin/maas shell\nWelcome to the MAAS shell.\n\nPredefined variables:\n\n    origin: A `viscera` origin, configured for foo.\n   session: A `bones` session, configured for foo.\n\n>>>",
            "title": "Logging-in"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-out",
            "text": "Log-out using the command-line tool:  $ bin/maas profiles remove foo  or, programmatically:  >>> with ProfileStore.open() as store:\n...     store.delete(\"foo\")",
            "title": "Logging-out"
        },
        {
            "location": "/viscera/getting-started/index.html#dir-help-and-tab-completion",
            "text": "The  viscera  API has been designed to be very discoverable using\ntab-completion,  dir() ,  help() , and so on. Start with that:  >>> origin.<tab>\n\u2026  This works best when you\u2019ve got  IPython \ninstalled.",
            "title": "dir(), help(), and tab-completion"
        },
        {
            "location": "/viscera/nodes/index.html",
            "text": "Machines, devices, racks, and regions\n\n\n\nGiven an \nOrigin\n instance bound to your MAAS server, you can\ninterrogate your nodes with:\n\n\norigin.Machines.read()\n  # returns an origin.Machines instance, a\n  # sequence of origin.Machine instances.\n\norigin.Devices.read()\n  # returns an origin.Devices instance, a\n  # sequence of origin.Device instances.\n\norigin.RackControllers.read()\n  # returns an origin.RackControllers instance, a\n  # sequence of origin.RackController instances.\n\norigin.RegionControllers.read()\n  # returns an origin.RegionControllers instance, a\n  # sequence of origin.RegionController instances.\n\n\n\n\nAn example\n\n\n>>> for machine in origin.Machines.read():\n...     print(repr(node))\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nIndividual nodes can be read from the Web API.\n\n\n>>> machine = origin.Machine.read(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>\n\n\n\n\nMachines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:\n\n\n>>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4\n\n\n\n\nDon\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or\n\ndir(machine)\n to find out what other fields and methods are\navailable.\n\n\nTODO\n: Updating nodes.\n\n\nAllocating and deploying\n\n\n>>> help(origin.Machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = origin.Machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status_name)\nAcquired\n>>> machine.deploy()\n>>> print(machine.status_name)\nDeploying",
            "title": "Nodes"
        },
        {
            "location": "/viscera/nodes/index.html#an-example",
            "text": ">>> for machine in origin.Machines.read():\n...     print(repr(node))\n<Machine hostname='botswana' system_id='pncys4'>  Individual nodes can be read from the Web API.  >>> machine = origin.Machine.read(system_id=\"pncys4\")\n>>> machine\n<Machine hostname='botswana' system_id='pncys4'>  Machines \u2014 and devices, racks, and regions \u2014 have many useful\nattributes:  >>> machine.architecture\n'amd64/generic'\n>>> machine.cpus\n4  Don\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or dir(machine)  to find out what other fields and methods are\navailable.  TODO : Updating nodes.",
            "title": "An example"
        },
        {
            "location": "/viscera/nodes/index.html#allocating-and-deploying",
            "text": ">>> help(origin.Machines.allocate)\nHelp on method allocate in module maas.client.viscera.machines:\n\nallocate(\n    *, hostname:str=None, architecture:str=None, cpus:int=None,\n    memory:float=None, tags:typing.Sequence=None)\n  method of maas.client.viscera.machines.MachinesType instance\n    :param hostname: The hostname to match.\n    :param architecture: The architecture to match, e.g. \"amd64\".\n    :param cpus: The minimum number of CPUs to match.\n    :param memory: The minimum amount of RAM to match.\n    :param tags: The tags to match, as a sequence. Each tag may be\n        prefixed with a hyphen to denote that the given tag should NOT be\n        associated with a matched machine.\n>>> machine = origin.Machines.allocate(tags=(\"foo\", \"-bar\"))\n>>> print(machine.status_name)\nAcquired\n>>> machine.deploy()\n>>> print(machine.status_name)\nDeploying",
            "title": "Allocating and deploying"
        },
        {
            "location": "/viscera/events/index.html",
            "text": "Events\n\n\n\nEvents are similar to other \nviscera\n objects\u2026 but a little different\ntoo. The only way to get events is by the \nquery\n method:\n\n\n>>> events = origin.Events.query()\n\n\n\n\nThis accepts a plethora of optional arguments to narrow down the results:\n\n\n>>> events = origin.Events.query(hostnames={\"foo\", \"bar\"})\n>>> events = origin.Events.query(domains={\"example.com\", \"maas.io\"})\n>>> events = origin.Events.query(zones=[\"red\", \"blue\"])\n>>> events = origin.Events.query(macs=(\"12:34:56:78:90:ab\", ))\n>>> events = origin.Events.query(system_ids=\u2026)\n>>> events = origin.Events.query(agent_name=\u2026)\n>>> events = origin.Events.query(level=\u2026)\n>>> events = origin.Events.query(after=\u2026, limit=\u2026)\n\n\n\n\nThese arguments can be combined to narrow the results even further.\n\n\nThe \nlevel\n argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are defined in the\n\nLevel\n enum:\n\n\n>>> events = origin.Events.query(level=origin.Events.Level.ERROR)\n\n\n\n\nbut you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/viscera/other/index.html",
            "text": "Other objects\n\n\n\nThere are several other object types available via \nviscera\n. Use\n\ndir()\n and tab-completion to dig around interactively, or read the\ncode; we\u2019ve tried to keep it readable.\n\n\nFiles, users, tags\n\n\nSimilarly to nodes, these sets of objects can be fetched:\n\n\n>>> tags = origin.Tags.read()\n>>> files = origin.Files.read()\n>>> users = origin.Users.read()\n\n\n\n\nWhen reading from collections, as above, the returned object is\nlist-like:\n\n\n>>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4\n\n\n\n\nHowever, it\u2019s read-only:\n\n\n>>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Others"
        },
        {
            "location": "/viscera/other/index.html#files-users-tags",
            "text": "Similarly to nodes, these sets of objects can be fetched:  >>> tags = origin.Tags.read()\n>>> files = origin.Files.read()\n>>> users = origin.Users.read()  When reading from collections, as above, the returned object is\nlist-like:  >>> len(tags)\n5\n>>> tags[3]\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n>>> tags[3] in tags\nTrue\n>>> not_foo = [tag for tag in tags if tag.name != 'foo']\n>>> len(not_foo)\n4  However, it\u2019s read-only:  >>> tags[0] = \"bob\"\n\u2026\nTypeError: 'Tags' object does not support item assignment",
            "title": "Files, users, tags"
        }
    ]
}