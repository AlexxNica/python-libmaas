{
    "docs": [
        {
            "location": "/index.html",
            "text": "Welcome to MAAS\u2019s new command-line tool & Python client libraries.\n\n\nFor documentation on the MAAS server components, visit\n\nmaas.ubuntu.com\n.\n\n\nCommand-line\n\n\n$\n bin/maas profiles login --help\n\n$\n bin/maas profiles login exmpl http://example.com:5240/MAAS/ my_username\n\nPassword: \u2026\n\n\n$\n bin/maas list nodes\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\n\n\u2502 Hostname      \u2502 System ID \u2502 Architecture  \u2502 #CPUs \u2502 RAM    \u2502 Status    \u2502 Power \u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502 botswana.maas \u2502 433334    \u2502 amd64/generic \u2502 4     \u2502 8.0 GB \u2502 Ready     \u2502 Off   \u2502\n\n\n\u2502 namibia.maas  \u2502 433333    \u2502 amd64/generic \u2502 4     \u2502 8.0 GB \u2502 Allocated \u2502 Off   \u2502\n\n\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n\n\n\n\nClient libraries\n\n\nThere are two client libraries that make use of MAAS\u2019s Web API:\n\n\n\n\n\n\nA lower-level library that closely mirrors MAAS\u2019s Web API, referred to\n  as \nbones\n. The MAAS server publishes a description of its Web API and\n  \nbones\n provides a convenient mechanism to interact with it.\n\n\n\n\n\n\nA higher-level library that\u2019s designed for developers, referred to as\n  \nviscera\n. MAAS\u2019s Web API is sometimes unfriendly or inconsistent, but\n  \nviscera\n presents a saner API, designed for developers rather than\n  machines.\n\n\n\n\n\n\nThe implementation of \nviscera\n makes use of\n\nbones\n. \nViscera\n is the API that should be preferred\nfor application development.\n\n\nTry this next: \nGet started with \nviscera",
            "title": "Home"
        },
        {
            "location": "/index.html#welcome-to-maass-new-command-line-tool-python-client-libraries",
            "text": "For documentation on the MAAS server components, visit maas.ubuntu.com .",
            "title": "Welcome to MAAS's new command-line tool &amp; Python client libraries."
        },
        {
            "location": "/index.html#command-line",
            "text": "$  bin/maas profiles login --help $  bin/maas profiles login exmpl http://example.com:5240/MAAS/ my_username Password: \u2026  $  bin/maas list nodes \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502 Hostname      \u2502 System ID \u2502 Architecture  \u2502 #CPUs \u2502 RAM    \u2502 Status    \u2502 Power \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502 botswana.maas \u2502 433334    \u2502 amd64/generic \u2502 4     \u2502 8.0 GB \u2502 Ready     \u2502 Off   \u2502  \u2502 namibia.maas  \u2502 433333    \u2502 amd64/generic \u2502 4     \u2502 8.0 GB \u2502 Allocated \u2502 Off   \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
            "title": "Command-line"
        },
        {
            "location": "/index.html#client-libraries",
            "text": "There are two client libraries that make use of MAAS\u2019s Web API:    A lower-level library that closely mirrors MAAS\u2019s Web API, referred to\n  as  bones . The MAAS server publishes a description of its Web API and\n   bones  provides a convenient mechanism to interact with it.    A higher-level library that\u2019s designed for developers, referred to as\n   viscera . MAAS\u2019s Web API is sometimes unfriendly or inconsistent, but\n   viscera  presents a saner API, designed for developers rather than\n  machines.    The implementation of  viscera  makes use of bones .  Viscera  is the API that should be preferred\nfor application development.  Try this next:  Get started with  viscera",
            "title": "Client libraries"
        },
        {
            "location": "/bones/index.html",
            "text": "Bones\n: Low-level Python client API\n\n\nYou may prefer the \nhigher-level API \nviscera\n,\nbut maybe you need to do something that you can\u2019t do in \nviscera\n yet\n(please file a bug!), or you\u2019re developing \nviscera\n itself (which uses\n\nbones\n behind the scenes).\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\n\n\nfrom\n \nhttp\n \nimport\n \nHTTPStatus\n\n\nfrom\n \npprint\n \nimport\n \npprint\n\n\n\nfrom\n \nmaas.client\n \nimport\n \nbones\n\n\n\n\nprofile\n,\n \nsession\n \n=\n \nbones\n.\nSessionAPI\n.\nlogin\n(\n\n    \n\"http://localhost:5240/MAAS/\"\n,\n \nusername\n=\n\"alice\"\n,\n\n    \npassword\n=\n\"wonderland\"\n)\n\n\n\n# Create a tag if it doesn't exist.\n\n\ntag_name\n \n=\n \n\"gryphon\"\n\n\ntag_comment\n \n=\n \n\"Gryphon's Stuff\"\n\n\ntry\n:\n\n    \ntag\n \n=\n \nsession\n.\nTag\n.\nread\n(\nname\n=\ntag_name\n)\n\n\nexcept\n \nbones\n.\nCallError\n \nas\n \nerror\n:\n\n    \nif\n \nerror\n.\nstatus\n \n==\n \nHTTPStatus\n.\nNOT_FOUND\n:\n\n        \ntag\n \n=\n \nsession\n.\nTags\n.\nnew\n(\n\n            \nname\n=\ntag_name\n,\n \ncomment\n=\ntag_comment\n)\n\n    \nelse\n:\n\n        \nraise\n\n\n\n# List all the tags.\n\n\nprint\n(\n\">>> Tags.list()\"\n)\n\n\npprint\n(\nsession\n.\nTags\n.\nlist\n())\n\n\n\n# Get the system IDs for all nodes.\n\n\nprint\n(\n\">>> Nodes.list()\"\n)\n\n\nall_nodes_system_ids\n \n=\n \n[\n\n    \nnode\n[\n\"system_id\"\n]\n \nfor\n \nnode\n \nin\n \nsession\n.\nNodes\n.\nlist\n()\n\n\n]\n\n\npprint\n(\nall_nodes_system_ids\n)\n\n\n\n# Associate the tag with all nodes.\n\n\nprint\n(\n\">>> Tag.update_nodes()\"\n)\n\n\npprint\n(\nsession\n.\nTag\n.\nupdate_nodes\n(\n\n    \nname\n=\ntag\n[\n\"name\"\n],\n \nadd\n=\nall_nodes_system_ids\n))",
            "title": "Home"
        },
        {
            "location": "/bones/index.html#bones-low-level-python-client-api",
            "text": "You may prefer the  higher-level API  viscera ,\nbut maybe you need to do something that you can\u2019t do in  viscera  yet\n(please file a bug!), or you\u2019re developing  viscera  itself (which uses bones  behind the scenes).",
            "title": "Bones: Low-level Python client API"
        },
        {
            "location": "/bones/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5  from   http   import   HTTPStatus  from   pprint   import   pprint  from   maas.client   import   bones  profile ,   session   =   bones . SessionAPI . login ( \n     \"http://localhost:5240/MAAS/\" ,   username = \"alice\" , \n     password = \"wonderland\" )  # Create a tag if it doesn't exist.  tag_name   =   \"gryphon\"  tag_comment   =   \"Gryphon's Stuff\"  try : \n     tag   =   session . Tag . read ( name = tag_name )  except   bones . CallError   as   error : \n     if   error . status   ==   HTTPStatus . NOT_FOUND : \n         tag   =   session . Tags . new ( \n             name = tag_name ,   comment = tag_comment ) \n     else : \n         raise  # List all the tags.  print ( \">>> Tags.list()\" )  pprint ( session . Tags . list ())  # Get the system IDs for all nodes.  print ( \">>> Nodes.list()\" )  all_nodes_system_ids   =   [ \n     node [ \"system_id\" ]   for   node   in   session . Nodes . list ()  ]  pprint ( all_nodes_system_ids )  # Associate the tag with all nodes.  print ( \">>> Tag.update_nodes()\" )  pprint ( session . Tag . update_nodes ( \n     name = tag [ \"name\" ],   add = all_nodes_system_ids ))",
            "title": "Some example code"
        },
        {
            "location": "/viscera/index.html",
            "text": "Viscera\n: High-level Python client API\n\n\nSome example code\n\n\n#!/usr/bin/env python3.5\n\n\n\nfrom\n \npprint\n \nimport\n \npprint\n\n\n\nfrom\n \nmaas.client\n \nimport\n \nviscera\n\n\n\n\nprofile\n,\n \norigin\n \n=\n \nviscera\n.\nOrigin\n.\nlogin\n(\n\n    \n\"http://localhost:5240/MAAS/\"\n,\n \nusername\n=\n\"alice\"\n,\n\n    \npassword\n=\n\"wonderland\"\n)\n\n\n\n# List all the tags.\n\n\nprint\n(\n\">>> origin.Tags.read()\"\n)\n\n\npprint\n(\norigin\n.\nTags\n.\nread\n())\n\n\nprint\n(\n\">>> Or: list(origin.Tags)\"\n)\n\n\npprint\n(\nlist\n(\norigin\n.\nTags\n))\n\n\n\n# List all the nodes.\n\n\nprint\n(\n\">>> origin.Nodes.read()\"\n)\n\n\npprint\n(\norigin\n.\nNodes\n.\nread\n())\n\n\nprint\n(\n\">>> Or: list(origin.Nodes)\"\n)\n\n\npprint\n(\nlist\n(\norigin\n.\nNodes\n))",
            "title": "Home"
        },
        {
            "location": "/viscera/index.html#viscera-high-level-python-client-api",
            "text": "",
            "title": "Viscera: High-level Python client API"
        },
        {
            "location": "/viscera/index.html#some-example-code",
            "text": "#!/usr/bin/env python3.5  from   pprint   import   pprint  from   maas.client   import   viscera  profile ,   origin   =   viscera . Origin . login ( \n     \"http://localhost:5240/MAAS/\" ,   username = \"alice\" , \n     password = \"wonderland\" )  # List all the tags.  print ( \">>> origin.Tags.read()\" )  pprint ( origin . Tags . read ())  print ( \">>> Or: list(origin.Tags)\" )  pprint ( list ( origin . Tags ))  # List all the nodes.  print ( \">>> origin.Nodes.read()\" )  pprint ( origin . Nodes . read ())  print ( \">>> Or: list(origin.Nodes)\" )  pprint ( list ( origin . Nodes ))",
            "title": "Some example code"
        },
        {
            "location": "/viscera/getting-started/index.html",
            "text": "Getting started with \nviscera\n\n\nInstallation\n\n\nEither work from a branch:\n\n\n$\n git clone https://github.com/maas/python-libmaas.git\n\n$\n \ncd\n python-libmaas\n\n$\n make\n\n\n\n\n\nOr install with \npip\n into a\n\nvirtualenv\n:\n\n\n$\n virtualenv --python\n=\npython3.5 amc \n&&\n \nsource\n amc/bin/activate\n\n$\n pip install git+https://github.com/maas/python-libmaas.git\n\n\n\n\n\nOr install from \nPyPI\n:\n\n\n$\n virtualenv --python\n=\npython3.5 amc \n&&\n \nsource\n amc/bin/activate\n\n$\n pip install python-libmaas\n\n\n\n\n\nNote\n that PyPI may lag the others.\n\n\nLogging-in\n\n\nLog-in using the command-line tool and start an interactive Python\nshell:\n\n\n$\n maas profiles login foo http://example.com:5240/MAAS/ admin\n\nPassword: \u2026\n\n\n$\n maas shell\n\n\n\n\n\nThis will provide you with a pre-prepared \norigin\n object that points to\n\nfoo\n from above. This is the root object of the API.\n\n\nYou can also log-in programmatically:\n\n\n>>> \nprofile\n,\n \norigin\n \n=\n \nOrigin\n.\nlogin\n(\n\n\n... \n    \n\"http://example.com:5240/MAAS/\"\n,\n \nusername\n=\n\"admin\"\n,\n\n\n... \n    \npassword\n=\n\"\u2026\"\n)\n\n\n\n\n\n\nThe \nprofile\n has not been saved, but it\u2019s easy to do so:\n\n\n>>> \nprofile\n \n=\n \nprofile\n.\nreplace\n(\nname\n=\n\"foo\"\n)\n\n\n>>> \nwith\n \nProfileStore\n.\nopen\n()\n \nas\n \nstore\n:\n\n\n... \n    \nstore\n.\nsave\n(\nprofile\n)\n\n\n... \n    \nstore\n.\ndefault\n \n=\n \nprofile\n\n\n\n\n\n\nThis does the same as the \nmaas profiles login\n command.\n\n\nBut there\u2019s no need! There\u2019s a command built in to do it for you:\n\n\n$\n bin/maas shell\n\nWelcome to the MAAS shell.\n\n\n\nPredefined variables:\n\n\n\n    origin: A `viscera` origin, configured for foo.\n\n\n   session: A `bones` session, configured for foo.\n\n\n\n>\n>>\n\n\n\n\n\nLogging-out\n\n\nLog-out using the command-line tool:\n\n\n$\n bin/maas profiles remove foo\n\n\n\n\n\nor, programmatically:\n\n\n>>> \nwith\n \nProfileStore\n.\nopen\n()\n \nas\n \nstore\n:\n\n\n... \n    \nstore\n.\ndelete\n(\n\"foo\"\n)\n\n\n\n\n\n\ndir()\n, \nhelp()\n, and tab-completion\n\n\nThe \nviscera\n API has been designed to be very discoverable using\ntab-completion, \ndir()\n, \nhelp()\n, and so on. Start with that:\n\n\n>>> \norigin\n.<\ntab\n>\n\n\n\u2026\n\n\n\n\n\n\nThis works best when you\u2019ve got \nIPython\n\ninstalled.",
            "title": "Getting started"
        },
        {
            "location": "/viscera/getting-started/index.html#getting-started-with-viscera",
            "text": "",
            "title": "Getting started with viscera"
        },
        {
            "location": "/viscera/getting-started/index.html#installation",
            "text": "Either work from a branch:  $  git clone https://github.com/maas/python-libmaas.git $   cd  python-libmaas $  make  Or install with  pip  into a virtualenv :  $  virtualenv --python = python3.5 amc  &&   source  amc/bin/activate $  pip install git+https://github.com/maas/python-libmaas.git  Or install from  PyPI :  $  virtualenv --python = python3.5 amc  &&   source  amc/bin/activate $  pip install python-libmaas  Note  that PyPI may lag the others.",
            "title": "Installation"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-in",
            "text": "Log-in using the command-line tool and start an interactive Python\nshell:  $  maas profiles login foo http://example.com:5240/MAAS/ admin Password: \u2026  $  maas shell  This will provide you with a pre-prepared  origin  object that points to foo  from above. This is the root object of the API.  You can also log-in programmatically:  >>>  profile ,   origin   =   Origin . login (  ...       \"http://example.com:5240/MAAS/\" ,   username = \"admin\" ,  ...       password = \"\u2026\" )   The  profile  has not been saved, but it\u2019s easy to do so:  >>>  profile   =   profile . replace ( name = \"foo\" )  >>>  with   ProfileStore . open ()   as   store :  ...       store . save ( profile )  ...       store . default   =   profile   This does the same as the  maas profiles login  command.  But there\u2019s no need! There\u2019s a command built in to do it for you:  $  bin/maas shell Welcome to the MAAS shell.  Predefined variables:      origin: A `viscera` origin, configured for foo.     session: A `bones` session, configured for foo.  > >>",
            "title": "Logging-in"
        },
        {
            "location": "/viscera/getting-started/index.html#logging-out",
            "text": "Log-out using the command-line tool:  $  bin/maas profiles remove foo  or, programmatically:  >>>  with   ProfileStore . open ()   as   store :  ...       store . delete ( \"foo\" )",
            "title": "Logging-out"
        },
        {
            "location": "/viscera/getting-started/index.html#dir-help-and-tab-completion",
            "text": "The  viscera  API has been designed to be very discoverable using\ntab-completion,  dir() ,  help() , and so on. Start with that:  >>>  origin .< tab >  \u2026   This works best when you\u2019ve got  IPython \ninstalled.",
            "title": "dir(), help(), and tab-completion"
        },
        {
            "location": "/viscera/nodes/index.html",
            "text": "Viscera\n: Working with nodes\n\n\nListing\n\n\n>>> \nfor\n \nnode\n \nin\n \norigin\n.\nNodes\n:\n\n\n... \n    \nprint\n(\nrepr\n(\nnode\n))\n\n\n<Node hostname='namibia.maas' system_id='433333'>\n\n\n<Node hostname='botswana.maas' system_id='433334'>\n\n\n\n\n\n\nIndividual nodes can be read from the Web API.\n\n\n>>> \nnode\n \n=\n \norigin\n.\nNode\n.\nread\n(\nsystem_id\n=\n\"433333\"\n)\n\n\n\n\n\n\nNodes have many useful attributes:\n\n\n>>> \nnode\n.\narchitecture\n\n\n'amd64/generic'\n\n\n>>> \nnode\n.\ncpus\n\n\n4\n\n\n\n\n\n\nDon\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or\n\ndir(node)\n to find out what other fields and methods are available.\n\n\nTODO\n: Updating nodes.\n\n\nAcquiring and starting\n\n\n>>> \nhelp\n(\norigin\n.\nNodes\n.\nacquire\n)\n\n\nacquire(*, hostname:str=None, architecture:str=None, cpus:int=None,\n\n\n        memory:float=None, tags:typing.Sequence=None) method of\n\n\n            maas.client.viscera.NodesType instance\n\n\n    :param hostname: The hostname to match.\n\n\n    :param architecture: The architecture to match, e.g. \"amd64\".\n\n\n    :param cpus: The minimum number of CPUs to match.\n\n\n    :param memory: The minimum amount of RAM to match.\n\n\n    :param tags: The tags to match, as a sequence. Each tag may be\n\n\n        prefixed with a hyphen to denote that the given tag should NOT be\n\n\n        associated with a matched node.\n\n\n>>> \nnode\n \n=\n \norigin\n.\nNodes\n.\nacquire\n(\ntags\n=\n(\n\"foo\"\n,\n \n\"-bar\"\n))\n\n\n>>> \nprint\n(\nnode\n.\nstatus_name\n)\n\n\nAcquired\n\n\n>>> \nnode\n.\nstart\n()\n\n\n>>> \nprint\n(\nnode\n.\nstatus_name\n)\n\n\nDeploying",
            "title": "Nodes"
        },
        {
            "location": "/viscera/nodes/index.html#viscera-working-with-nodes",
            "text": "",
            "title": "Viscera: Working with nodes"
        },
        {
            "location": "/viscera/nodes/index.html#listing",
            "text": ">>>  for   node   in   origin . Nodes :  ...       print ( repr ( node ))  <Node hostname='namibia.maas' system_id='433333'>  <Node hostname='botswana.maas' system_id='433334'>   Individual nodes can be read from the Web API.  >>>  node   =   origin . Node . read ( system_id = \"433333\" )   Nodes have many useful attributes:  >>>  node . architecture  'amd64/generic'  >>>  node . cpus  4   Don\u2019t forget to try using tab-completion \u2014 the objects have been\ndesigned to be particularly friendly for interactive use \u2014 or dir(node)  to find out what other fields and methods are available.  TODO : Updating nodes.",
            "title": "Listing"
        },
        {
            "location": "/viscera/nodes/index.html#acquiring-and-starting",
            "text": ">>>  help ( origin . Nodes . acquire )  acquire(*, hostname:str=None, architecture:str=None, cpus:int=None,          memory:float=None, tags:typing.Sequence=None) method of              maas.client.viscera.NodesType instance      :param hostname: The hostname to match.      :param architecture: The architecture to match, e.g. \"amd64\".      :param cpus: The minimum number of CPUs to match.      :param memory: The minimum amount of RAM to match.      :param tags: The tags to match, as a sequence. Each tag may be          prefixed with a hyphen to denote that the given tag should NOT be          associated with a matched node.  >>>  node   =   origin . Nodes . acquire ( tags = ( \"foo\" ,   \"-bar\" ))  >>>  print ( node . status_name )  Acquired  >>>  node . start ()  >>>  print ( node . status_name )  Deploying",
            "title": "Acquiring and starting"
        },
        {
            "location": "/viscera/events/index.html",
            "text": "Events\n\n\nEvents are similar\u2026 but different. The only way to get events is by\nthe \nquery\n method:\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n()\n\n\n\n\n\n\nThis accepts a plethora of optional arguments to narrow down the results:\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nhostnames\n=\n{\n\"foo\"\n,\n \n\"bar\"\n})\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\ndomains\n=\n{\n\"example.com\"\n,\n \n\"maas.io\"\n})\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nzones\n=\n[\n\"red\"\n,\n \n\"blue\"\n])\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nmacs\n=\n(\n\"12:34:56:78:90:ab\"\n,\n \n))\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nsystem_ids\n=\n\u2026\n)\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nagent_name\n=\n\u2026\n)\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nlevel\n=\n\u2026\n)\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nafter\n=\n\u2026\n,\n \nlimit\n=\n\u2026\n)\n\n\n\n\n\n\nThese arguments can be combined to narrow the results even further.\n\n\nThe \nlevel\n argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are defined in the\n\nLevel\n enum:\n\n\n>>> \nevents\n \n=\n \norigin\n.\nEvents\n.\nquery\n(\nlevel\n=\norigin\n.\nEvents\n.\nLevel\n.\nERROR\n)\n\n\n\n\n\n\nbut you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/viscera/events/index.html#events",
            "text": "Events are similar\u2026 but different. The only way to get events is by\nthe  query  method:  >>>  events   =   origin . Events . query ()   This accepts a plethora of optional arguments to narrow down the results:  >>>  events   =   origin . Events . query ( hostnames = { \"foo\" ,   \"bar\" })  >>>  events   =   origin . Events . query ( domains = { \"example.com\" ,   \"maas.io\" })  >>>  events   =   origin . Events . query ( zones = [ \"red\" ,   \"blue\" ])  >>>  events   =   origin . Events . query ( macs = ( \"12:34:56:78:90:ab\" ,   ))  >>>  events   =   origin . Events . query ( system_ids = \u2026 )  >>>  events   =   origin . Events . query ( agent_name = \u2026 )  >>>  events   =   origin . Events . query ( level = \u2026 )  >>>  events   =   origin . Events . query ( after = \u2026 ,   limit = \u2026 )   These arguments can be combined to narrow the results even further.  The  level  argument is a little special. It\u2019s a choice from a\npredefined set. For convenience, those choices are defined in the Level  enum:  >>>  events   =   origin . Events . query ( level = origin . Events . Level . ERROR )   but you can also pass in the string \u201cERROR\u201d or the number 40.",
            "title": "Events"
        },
        {
            "location": "/viscera/other/index.html",
            "text": "Other objects\n\n\nFiles, users, tags\n\n\nSimilarly to nodes, these sets of objects can be fetched:\n\n\n>>> \ntags\n \n=\n \norigin\n.\nTags\n.\nread\n()\n\n\n>>> \nfiles\n \n=\n \norigin\n.\nFiles\n.\nread\n()\n\n\n>>> \nusers\n \n=\n \norigin\n.\nUsers\n.\nread\n()\n\n\n\n\n\n\nWhen reading from collections, as above, the returned object is\nlist-like:\n\n\n>>> \nlen\n(\ntags\n)\n\n\n5\n\n\n>>> \ntags\n[\n3\n]\n\n\n<Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>\n\n\n>>> \ntags\n[\n3\n]\n \nin\n \ntags\n\n\nTrue\n\n\n>>> \nnot_foo\n \n=\n \n[\ntag\n \nfor\n \ntag\n \nin\n \ntags\n \nif\n \ntag\n.\nname\n \n!=\n \n'foo'\n]\n\n\n>>> \nlen\n(\nnot_foo\n)\n\n\n4\n\n\n\n\n\n\nHowever, it\u2019s read-only:\n\n\n>>> \ntags\n[\n0\n]\n \n=\n \n\"bob\"\n\n\n\u2026\n\n\nTypeError: 'Tags' object does not support item assignment",
            "title": "Other objects"
        },
        {
            "location": "/viscera/other/index.html#other-objects",
            "text": "",
            "title": "Other objects"
        },
        {
            "location": "/viscera/other/index.html#files-users-tags",
            "text": "Similarly to nodes, these sets of objects can be fetched:  >>>  tags   =   origin . Tags . read ()  >>>  files   =   origin . Files . read ()  >>>  users   =   origin . Users . read ()   When reading from collections, as above, the returned object is\nlist-like:  >>>  len ( tags )  5  >>>  tags [ 3 ]  <Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'>  >>>  tags [ 3 ]   in   tags  True  >>>  not_foo   =   [ tag   for   tag   in   tags   if   tag . name   !=   'foo' ]  >>>  len ( not_foo )  4   However, it\u2019s read-only:  >>>  tags [ 0 ]   =   \"bob\"  \u2026  TypeError: 'Tags' object does not support item assignment",
            "title": "Files, users, tags"
        }
    ]
}